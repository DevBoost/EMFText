modeltype JAVA uses "http://www.emftext.org/java";

-- in place now also possible
-- 'inout' was needed
-- in principle all methods and attributes are used,
-- they need to be removed manually using the 'exclude' method

transformation for2foreach(inout javaModel : JAVA);

// this is only used to count the number of processed classes
mapping inout JAVA::classifiers::Class::countClasses(){}
// this is only used to count the number of processed for loops
mapping inout JAVA::statements::ForLoop::countForLoops(){}
// this is only used to count the number of replaced for loops
mapping inout JAVA::statements::ForEachLoop::countForLoopReplacements(){}

main() {
	javaModel.objects()[JAVA::classifiers::Class]->map countClasses();
	javaModel.objects()[JAVA::statements::ForLoop]->map countForLoops();
	javaModel.objects()[JAVA::statements::StatementListContainer]->map Statements_StatementListContainer();
	javaModel.objects()[JAVA::statements::StatementContainer]->map Statements_StatementContainer();
}

// transforms the statement to a for loop if possible
mapping inout JAVA::statements::StatementContainer::Statements_StatementContainer() {
	var forEachLoop : JAVA::statements::ForEachLoop := null;
		if self.statement.oclIsTypeOf(JAVA::statements::ForLoop) then
			forEachLoop  := map transformStatementToForeachLoopIfPossible(self.statement.oclAsType(JAVA::statements::ForLoop))
		endif;	
	if forEachLoop <> null then
		self.statement := forEachLoop
	endif;
}


// iterates over all statements in the container and transforms for loops if possible
mapping inout JAVA::statements::StatementListContainer::Statements_StatementListContainer() {
	var transformedStatements : OrderedSet(JAVA::statements::Statement);
	// inspect all statements in the container
	self.statements->forEach(s) {
		// transform statement to for-each loop if possible
		var forEachLoop : JAVA::statements::ForEachLoop := null;
		if s.oclIsTypeOf(JAVA::statements::ForLoop) then
			forEachLoop  := map transformStatementToForeachLoopIfPossible(s.oclAsType(JAVA::statements::ForLoop))
		endif;	
		// if statement was transformed to for-each loop replace orignial statement, otherwise keep original
		if forEachLoop <> null then
			transformedStatements := transformedStatements->append(forEachLoop)
		else
			transformedStatements := transformedStatements->append(s)
		endif;
	};
	// replace old statement list with transformed ones
	self.statements := transformedStatements;
}


// checks whether the statement is a for loop, 
// whether this loop fulfills a number of
// preconditions for replacements and transforms 
// it to a foreach loop if possible
mapping transformStatementToForeachLoopIfPossible
	(forLoop : JAVA::statements::ForLoop) 
	: JAVA::statements::ForEachLoop
	// check pre-conditions for loop replacement
	when {
		// loop initialisation is fine?
		forLoop.checkInit() and 
		// loop condition is fine?
		forLoop.checkCondition() and 
		// counting expression is fine?
		forLoop.checkCountingExpression() and 
		// loop body is fine?
		forLoop.checkStatements() 
	}
	{

	// find the identifier of the old 
	// for loop counter variable
	var counterIdentifier 
		: JAVA::_references::IdentifierReference 
		:= findCounterIdentifier(forLoop);	
	
	// calculate the generic type of the iterated list
	var listType 
		: JAVA::types::TypeReference 
		:= calculateListType(counterIdentifier);
	
	// create  iteration parameter for the 
	// new foreach loop
	var loopParameter 
		:= object JAVA::parameters::OrdinaryParameter {
			name := "element";
			typeReference := listType
	};
	
	// count replacement in statistics
	result->map countForLoopReplacements();
	
	// replace old for loop with new foreach loop
	result.next := loopParameter;
	result.collection := counterIdentifier;
	
	result.statement := 
		map replaceCollectionAccessorStatements(
		forLoop.statement
			.oclAsType(JAVA::statements::Block),
		counterIdentifier,
		loopParameter);
}



// replace all collection accesses with foreach parameter
mapping replaceCollectionAccessorStatements(
	in block : JAVA::statements::Block,
	in counterVariable : JAVA::_references::IdentifierReference,
	in loopParameter : JAVA::parameters::OrdinaryParameter) :
		JAVA::statements::Block {
		
		block.allSubobjects()[JAVA::_references::IdentifierReference].
			map replaceCounterVariableReferenceWithLoopParameter(counterVariable,loopParameter);
						
		result.statements := block.statements;
		result.name := block.name;
		result.modifiers := block.modifiers
	}

// replace old counter variable reference with new loop iteration parameter
mapping inout JAVA::_references::IdentifierReference::replaceCounterVariableReferenceWithLoopParameter (
	in counterVariable : JAVA::_references::IdentifierReference,
	in loopParameter : JAVA::parameters::OrdinaryParameter)
	
	when{
		self.target.name = counterVariable.target.name
	}
	{
		target := loopParameter;
		next := null;
	}


helper JAVA::statements::ForLoop::checkInit() : Boolean {
 	return self._init.oclIsTypeOf(JAVA::variables::LocalVariable) and
 		self._init.oclAsType(JAVA::variables::LocalVariable).initialValue.oclIsKindOf(JAVA::literals::DecimalIntegerLiteral) and
 		self._init.oclAsType(JAVA::variables::LocalVariable).initialValue.oclAsType(JAVA::literals::DecimalIntegerLiteral).decimalValue = 0;
}


helper JAVA::statements::ForLoop::checkCondition() : Boolean {
	return self.condition.oclIsTypeOf(JAVA::expressions::RelationExpression);
}

helper JAVA::statements::ForLoop::checkCountingExpression() : Boolean {
 	return self.updates->size() = 1 and let update = self.updates->first() in 
 		update.oclIsTypeOf(JAVA::expressions::SuffixUnaryModificationExpression) 
 		and
 		update.oclAsType(JAVA::expressions::SuffixUnaryModificationExpression).operator.oclIsTypeOf(JAVA::operators::PlusPlus)
 	;
}

helper JAVA::statements::ForLoop::checkStatements() : Boolean {
	var counterVarName = self._init.oclAsType(JAVA::variables::LocalVariable).name;
	var listName = self.condition.oclAsType(JAVA::expressions::RelationExpression).children->at(2).oclAsType(JAVA::_references::IdentifierReference).target.name;
	
	var counterReferences = self.statement.oclAsType(JAVA::statements::Block).allSubobjects()[JAVA::_references::IdentifierReference]->select(t | t.target.name = counterVarName);
	return counterReferences->forAll(r:JAVA::_references::IdentifierReference | r.container().oclIsTypeOf(JAVA::_references::MethodCall) and
				 r.container().oclAsType(JAVA::_references::MethodCall).target.name = "get" and
				 r.container().oclAsType(JAVA::_references::MethodCall).container().oclIsTypeOf(JAVA::_references::IdentifierReference) and
				 r.container().oclAsType(JAVA::_references::MethodCall).container().oclAsType(JAVA::_references::IdentifierReference).target.name = listName);
}

query findCounterIdentifier(forLoop : JAVA::statements::ForLoop) : JAVA::_references::IdentifierReference {
	
	var forCondition : JAVA::expressions::RelationExpression := forLoop.condition.oclAsType(JAVA::expressions::RelationExpression);
	var counterIdentifier: JAVA::_references::IdentifierReference := null;
	if forCondition <> null then
		if forCondition.children->at(2).oclIsTypeOf(JAVA::_references::IdentifierReference) then {
			counterIdentifier := forCondition.children->at(2).oclAsType(JAVA::_references::IdentifierReference);
			if counterIdentifier <> null then
				counterIdentifier.next := null
			endif;
			
		}
		endif
	endif;
	return counterIdentifier;
}


query findCounterVariable(counterIdentifier : JAVA::_references::IdentifierReference) :  JAVA::variables::Variable {
	var counterVariable : JAVA::variables::Variable := null;
	if counterIdentifier <> null then
		counterVariable := findCounterVarInLocalVariables(counterIdentifier.target)
	endif;
	if counterVariable = null and counterIdentifier <> null then
		counterVariable := findCounterVarInFields(counterIdentifier.target)
	endif;
	return counterVariable;
}

query calculateListType(counterIdentifier: JAVA::_references::IdentifierReference) : JAVA::types::TypeReference {
	var counterVariable : JAVA::variables::Variable := findCounterVariable(counterIdentifier);
	return counterVariable.typeReference.oclAsType(JAVA::types::NamespaceClassifierReference).
		classifierReferences->at(1).typeArguments->at(1).
		oclAsType(JAVA::generics::QualifiedTypeArgument).typeReference.
		deepclone().oclAsType(JAVA::types::NamespaceClassifierReference);	
}

// sucht die lokale variable in einer methode, welche im if-statement der condition gesetzt wird
query findCounterVarInLocalVariables(c : JAVA::_references::ReferenceableElement) : 
	JAVA::variables::LocalVariable {
	return	javaModel.objects()[JAVA::variables::LocalVariable]->selectOne(l|
			l.name = c.name);
}

// sucht das feld in der klasse, welches im if-statement der condition gesetzt wird
query findCounterVarInFields(c : JAVA::_references::ReferenceableElement) : 
	JAVA::members::Field {
	return	javaModel.objects()[JAVA::members::Field]->selectOne(f|
			f.name = c.name);
}