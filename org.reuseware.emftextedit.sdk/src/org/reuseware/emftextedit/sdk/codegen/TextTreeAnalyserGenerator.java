package org.reuseware.emftextedit.sdk.codegen;

import java.io.PrintWriter;

import org.eclipse.emf.codegen.ecore.genmodel.GenClass;
import org.eclipse.emf.codegen.ecore.genmodel.GenFeature;
import org.eclipse.emf.codegen.ecore.genmodel.GenPackage;
import org.eclipse.emf.common.util.BasicEList;
import org.eclipse.emf.common.util.EList;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

public class TextTreeAnalyserGenerator extends BaseGenerator {
	
	private String resolverImplementationPackage;
	private Map<GenFeature, String> proxyReferences;
	
	/**
	 * 
	 * 
	 * @param proxyReferences - a Map which contains all GenFeatures which where referenced and 
	 * a mapping to the corresponding resolver class which was generated.
	 * @param analyserPackageName
	 * @param analyserClassName
	 * @param resolverImplementationPackage
	 */
	
	public TextTreeAnalyserGenerator(Map<GenFeature, String> proxyReferences, String analyserClassName, String analyserPackageName, String resolverImplementationPackage){
		super(analyserClassName,analyserPackageName);
		this.resolverImplementationPackage = resolverImplementationPackage;
		this.proxyReferences = proxyReferences;
	}
	
	@Override
	public boolean generate(PrintWriter out) {
		out.print(generateTreeAnalyser(proxyReferences));
		return true;
	}
	
	 /**
     * Generates the tree analyser that searches the output of the parser for proxies and calls the corresponding
     * proxy resolvers generated by <code>generateProxyResolver()</code>.
     */
    protected String generateTreeAnalyser(Map<GenFeature, String> proxyReferences)  {  
    	List<String> generatedResolvers = new ArrayList<String>();
    	StringBuffer s = new StringBuffer();
     	
        s.append("package " + super.getResourcePackageName() + "; \n\n");

        s.append("import org.eclipse.emf.ecore.EObject;\n");
        s.append("import org.eclipse.emf.ecore.EReference;\n");
        s.append("import org.eclipse.emf.ecore.InternalEObject;\n");
        s.append("import org.reuseware.emftextedit.runtime.resource.TextResource;\n");

        s.append("import org.reuseware.emftextedit.runtime.resource.impl.*;\n\n");
        
        //import required EClasses
        EList<GenClass> importedClasses = new BasicEList<GenClass>();
        for(GenFeature proxyReference : proxyReferences.keySet()) {
        	GenClass genClass = proxyReference.getGenClass();
        	GenPackage p = genClass.getGenPackage();
        	String base = p.getBasePackage() == null ? "" : (p.getBasePackage() +".");
        	String classImport =  base + p.getEcorePackage().getName() + "." + genClass.getName();
            if (!importedClasses.contains(genClass)) {
            	s.append("import "+ classImport + ";\n");
            	importedClasses.add(genClass);
            }
        }

        if (!proxyReferences.isEmpty()) s.append("import " + resolverImplementationPackage + ".*;\n\n");
		
		s.append("public class " + super.getResourceClassName() + " extends EMFTextTreeAnalyserImpl {\n\n");
		
		for(GenFeature proxyReference : proxyReferences.keySet()) {
			String generatedClassName = proxyReferences.get(proxyReference);
			if (!generatedResolvers.contains(generatedClassName)) {
				generatedResolvers.add(generatedClassName);
				s.append("\tprotected " + generatedClassName + " " + low(generatedClassName) + " = new " + generatedClassName + "();\n\n");			
			}
		}
		
		s.append("\tpublic EObject resolve(InternalEObject proxy, EObject container, EReference reference, TextResource resource, boolean reportErrors) {\n");
		for(GenFeature proxyReference : proxyReferences.keySet()) {
			String generatedClassName = proxyReferences.get(proxyReference);
			s.append("\t\tif (container instanceof " + proxyReference.getGenClass().getName() + " && reference.getFeatureID() == " + proxyReference.getGenClass().getEcoreClass().getEStructuralFeature(proxyReference.getName()).getFeatureID() + ") {\n");		
			s.append("\t\t\treturn " + low(generatedClassName)+".resolve(proxy,container,reference,resource,reportErrors);\n");			
			s.append("\t\t}\n");			
		}
		s.append("\t\treturn null;\n");
		s.append("\t}\n\n");   
        
		s.append("\tpublic String deResolve(EObject refObject, EObject container, EReference reference) {\n");
		for(GenFeature proxyReference : proxyReferences.keySet()) {
			String generatedClassName = proxyReferences.get(proxyReference);
			s.append("\t\tif (container instanceof " + proxyReference.getGenClass().getName() + " && reference.getFeatureID() == " + proxyReference.getGenClass().getEcoreClass().getEStructuralFeature(proxyReference.getName()).getFeatureID() + ") {\n");		
			s.append("\t\t\treturn " + low(generatedClassName)+".deResolve(refObject,container,reference);\n");			
			s.append("\t\t}\n");			
		}
		s.append("\t\treturn null;\n");
		s.append("\t}\n\n");   
        
        s.append("\tpublic void setOptions(java.util.Map<?, ?> options) {\n");
		for(GenFeature proxyReference : proxyReferences.keySet()) {
			String generatedClassName = proxyReferences.get(proxyReference);
			s.append("\t\t" + low(generatedClassName) + ".setOptions(options);\n");			
		}
		s.append("\t}\n");

		s.append("}\n");
        
    	return s.toString();	
    }
}
