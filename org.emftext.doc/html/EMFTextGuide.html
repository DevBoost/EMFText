<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title></title> 
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- html --> 
<meta name="src" content="EMFTextGuide.tex"> 
<meta name="date" content="2010-08-09 15:06:00"> 
<link rel="stylesheet" type="text/css" href="EMFTextGuide.css"> 
</head><body 
>
  <div class="titlepage">
                                                                                     

                                                                                     
                                                                                     

                                                                                     
<!--l. 40--><p class="indent" >
                                                                                     

                                                                                     

<!--l. 47--><p class="noindent" ><img 
src="../latex/figures/EMFTextLogo.png" alt="PIC"  
>
<!--l. 53--><p class="noindent" ><span 
class="aecsc-10x-x-600">U<span 
class="small-caps">s</span><span 
class="small-caps">e</span><span 
class="small-caps">r</span> G<span 
class="small-caps">u</span><span 
class="small-caps">i</span><span 
class="small-caps">d</span><span 
class="small-caps">e</span></span>
                                                                                     <div class="flushright" 
><!--l. 58--><p class="noindent" >
 <span 
class="aer12-">August 9, 2010</span></div>
                                                                                     

                                                                                     
  </div>
                                                                                     

                                                                                     
                                                                                     

                                                                                     
                                                                                     

                                                                                     
                                                                                     

                                                                                     
  <h2 class="likechapterHead"><a 
 id="x1-1000"></a>Contents</h2>
  <div class="tableofcontents">
  <span class="chapterToc" >1&#x00A0;&#x00A0;<a 
href="#x1-40001" id="QQ2-1-4">Overview</a></span>
<br />  <span class="chapterToc" >2&#x00A0;&#x00A0;<a 
href="#x1-50002" id="QQ2-1-5">Development Process</a></span>
<br />  <span class="chapterToc" >3&#x00A0;&#x00A0;<a 
href="#x1-60003" id="QQ2-1-6">Concrete Syntax Specification Language (CS)</a></span>
<br />  &#x00A0;<span class="sectionToc" >3.1&#x00A0;&#x00A0;<a 
href="#x1-70003.1" id="QQ2-1-7">Configuration Block</a></span>
<br />  &#x00A0;&#x00A0;<span class="subsectionToc" >3.1.1&#x00A0;&#x00A0;<a 
href="#x1-80003.1.1" id="QQ2-1-8">Required General Information</a></span>
<br />  &#x00A0;&#x00A0;<span class="subsectionToc" >3.1.2&#x00A0;&#x00A0;<a 
href="#x1-90003.1.2" id="QQ2-1-9">Importing other Models and Syntaxes</a></span>
<br />  &#x00A0;&#x00A0;<span class="subsectionToc" >3.1.3&#x00A0;&#x00A0;<a 
href="#x1-100003.1.3" id="QQ2-1-10">Code Generation Options</a></span>
<br />  &#x00A0;<span class="sectionToc" >3.2&#x00A0;&#x00A0;<a 
href="#x1-110003.2" id="QQ2-1-11">Tokens</a></span>
<br />  &#x00A0;&#x00A0;<span class="subsectionToc" >3.2.1&#x00A0;&#x00A0;<a 
href="#x1-120003.2.1" id="QQ2-1-12">Simple, custom tokens</a></span>
<br />  &#x00A0;&#x00A0;<span class="subsectionToc" >3.2.2&#x00A0;&#x00A0;<a 
href="#x1-130003.2.2" id="QQ2-1-13">Composed tokens</a></span>
<br />  &#x00A0;&#x00A0;<span class="subsectionToc" >3.2.3&#x00A0;&#x00A0;<a 
href="#x1-140003.2.3" id="QQ2-1-14">Tokens priorities</a></span>
<br />  &#x00A0;<span class="sectionToc" >3.3&#x00A0;&#x00A0;<a 
href="#x1-150003.3" id="QQ2-1-15">Token Styles</a></span>
<br />  &#x00A0;<span class="sectionToc" >3.4&#x00A0;&#x00A0;<a 
href="#x1-160003.4" id="QQ2-1-16">Syntax Rules</a></span>
<br />  &#x00A0;&#x00A0;<span class="subsectionToc" >3.4.1&#x00A0;&#x00A0;<a 
href="#x1-170003.4.1" id="QQ2-1-17">Simple Syntax</a></span>
<br />  &#x00A0;&#x00A0;<span class="subsectionToc" >3.4.2&#x00A0;&#x00A0;<a 
href="#x1-180003.4.2" id="QQ2-1-18">Syntax for attributes</a></span>
<br />  &#x00A0;&#x00A0;<span class="subsectionToc" >3.4.3&#x00A0;&#x00A0;<a 
href="#x1-190003.4.3" id="QQ2-1-19">Syntax for references</a></span>
<br />  &#x00A0;&#x00A0;<span class="subsectionToc" >3.4.4&#x00A0;&#x00A0;<a 
href="#x1-220003.4.4" id="QQ2-1-22">Syntax for printing instructions</a></span>
<br />  &#x00A0;&#x00A0;<span class="subsectionToc" >3.4.5&#x00A0;&#x00A0;<a 
href="#x1-250003.4.5" id="QQ2-1-25">Syntax for expressions</a></span>
<br />  &#x00A0;<span class="sectionToc" >3.5&#x00A0;&#x00A0;<a 
href="#x1-260003.5" id="QQ2-1-26">Suppressing warnings</a></span>
  </div>
                                                                                     

                                                                                     
                                                                                     

                                                                                     
  <h2 class="likechapterHead"><a 
 id="x1-2000"></a>List of Figures</h2>
<div class="tableofcontents">
</div>
                                                                                     

                                                                                     
                                                                                     

                                                                                     
                                                                                     

                                                                                     
                                                                                     

                                                                                     
  <h2 class="likechapterHead"><a 
 id="x1-3000"></a>List of Listings</h2>
                                                                                     

                                                                                     
                                                                                     

                                                                                     
                                                                                     

                                                                                     
                                                                                     

                                                                                     
                                                                                     

                                                                                     
                                                                                     

                                                                                     
  <h2 class="chapterHead"><span class="titlemark">1</span>&#x00A0;&#x00A0;<a 
 id="x1-40001"></a>Overview</h2>
<!--l. 3--><p class="noindent" >EMFText is a tool which allows users to define a plain textual syntax for their Ecore based
metamodel and to generate components to load, edit and store model instances. The syntax is
specified by a so called concrete syntax specification which are usually stored as files with
the suffix <span 
class="ul9r8t-x-x-95">.cs</span>. A <span 
class="ul9r8t-x-x-95">cs </span>specification is directly related to one ore more Ecore metamodel(s)
whose structure implicitly pretends a &#8221;grammar skeleton&#8221;. The following figure gives an
overview on how the generator part of EMFText works and what components it actually
generates.
<!--l. 13--><p class="indent" >  Through combining metamodel and <span 
class="ul9r8t-x-x-95">cs </span>specification, EMFText derives a context-free
grammar and exports it as an Another Tool for Language Recognition (ANTLR)&#x00A0;<span class="cite">[<span 
class="aebx-10x-x-109">?</span>]</span>
parser specification. This specification contains annotated semantic actions which cover
the largest part of metamodel instantiation. EMFText then transparently delegates
parser<span class="footnote-mark"><a 
href="EMFTextGuide2.html#fn1x1"><sup class="textsuperscript">1</sup></a></span><a 
 id="x1-4001f1"></a>  and
lexer<span class="footnote-mark"><a 
href="EMFTextGuide3.html#fn2x1"><sup class="textsuperscript">2</sup></a></span><a 
 id="x1-4002f2"></a> 
generation to ANTLR by passing the generated grammar file. Since ANTLR does not cover the whole
class of context-free grammars we can not guarantee the generation of a working parser for arbitrary
cases. However, in most cases generation should be sufficient.
<!--l. 23--><p class="indent" >  While parsers are used to load model instances from textual representations a printer is needed to
do the inverse, e.g. to print an in-memory instance of the metamodel back to a textual
representation. The printed results can then again be parsed by the corresponding parser. Both
instances (printed and loaded) should be equal. Furthermore, printers should produce a formatted
and human-readable output. The EMFText built-in printer generator tries to achieve these goals by
interpreting the <span 
class="ul9r8t-x-x-95">cs </span>file and the derived grammar. <span 
class="ul9r8t-x-x-95">cs </span>specifications can be enriched by
special operators to indicate that on a specific position white-spaces or newlines have to be
printed. Additionally, it uses information about literals (e.g. keywords) in defined languages
which are removed from model instances. As for parser generation, EMFText does not
guarantee that printer generation works for arbitrary cases but mostly it is be a convenient
solution.
<!--l. 36--><p class="indent" >  EMFText also generates a set of resolvers. Resolvers convert parsed token strings to an adequate
representation in the metamodel instance.
<!--l. 39--><p class="indent" >  TokenResolvers implement a mapping from the string value of a specific token to a native Java
type (e.g., boolean, int, String etc.). In the standard implementation TokenResolvers can
automatically remove and add (printing) pre- and suffixes. The conversion to native java
data types is done by delegation to the corresponding Java type conversion functions. For
example, <span 
class="ul9r8t-x-x-95">Integer.parseInt("42") </span>results in an int valued <span 
class="ul9r8t-x-x-95">42</span>. Since this behavior is only
desired for concrete syntaxes mirroring exactly (or at least partially) the Java syntax for
primitive types, users are expected to implement more adequate mapping functions as
needed.
<!--l. 48--><p class="indent" >  Resolvements depending on context are meant to be realised by implementing ReferenceResolvers.
                                                                                     

                                                                                     
For these only stubs are generated. While TokenResolvers are directly invoked by parsers,
ReferenceResolvers are triggered on demand later by EMF&#8217;s proxy resolution mechanism. An
additional feature is the evaluation of eventually annotated Object Constraint Language (OCL)&#x00A0;<span class="cite">[<span 
class="aebx-10x-x-109">?</span>]</span>
constraints. With OCL, consistency conditions can be declared on the metamodel to further improve
quality of EMFText based developments.
                                                                                     

                                                                                     
                                                                                     

                                                                                     
<!--l. 1--><p class="indent" >
                                                                                     

                                                                                     
  <h2 class="chapterHead"><span class="titlemark">2</span>&#x00A0;&#x00A0;<a 
 id="x1-50002"></a>Development Process</h2>
<!--l. 3--><p class="noindent" >Creating parsers, printers and editors with EMFText is easy! It involves some necessary steps which
are roughly depicted in the activity diagram below.
<!--l. 8--><p class="indent" >  The starting point usually is the &#8221;&#8217;Ecore-based model&#8221;&#8217; serving as an abstract syntax and as a
skeleton for concrete syntax. The model can be a graph or tree definition. Although Ecore models are
specified as XML files, it is recommended to use the Ecore model editor or an other graphical editor.
Additionally, a unique namespace (property NS URI in the .ecore file) for the models as well as a
package name needs to be specified. To enable EMFText to use models at runtime, a model plug-in
must be generated. For this, EMF provides a <span 
class="aesl-10x-x-109">generation metamodel </span>(GenModel) allowing to enrich
Ecore models with specific information for code generation. The EMF Model wizard facilitates the
creation of GenModels.
<!--l. 18--><p class="indent" >  The next step is to define the base package name which will be the common prefix for
all subsequently generated Java packages. After finishing configuration, the <span 
class="aesl-10x-x-109">EMF model</span>
<span 
class="aesl-10x-x-109">plug-in </span>is ready to be generated. EMFText will later use these classes to construct a model
instance.
<!--l. 23--><p class="indent" >  Since our metamodel is now defined, we can start specifying our <span 
class="aesl-10x-x-109">concrete syntax</span>. As a starting
point, EMFText provides a syntax generator that can automatically create a concrete-syntax
specification using HUTN (Human-Useable Textual Notation) from the metamodel. To
manually specify the concrete syntax, a textual specification has to be written, which has the
ending <span 
class="ul9r8t-x-x-95">cs </span>(from <span 
class="ul9r8t-x-x-95">c</span>oncrete <span 
class="ul9r8t-x-x-95">s</span>yntax). It consists of four sections: In the first part, a unique
name refers to the syntax as a specific resource type. Furthermore, the metamodel, whose
textual syntax shall be defined, has to be referenced by its unique namespace URI and a
start symbol must be selected from the model elements. In the second part, productions
from other concrete syntax specifications can be imported. This is especially useful if
the metamodel is compositionally structured, e.g. reuses large parts from other models
which have an already specified concrete syntax. The third part allows for specifying token
types as it is usual for parser generators, but in contrast, EMFText also allows to leave
them out: If no token definitions are given, default rules are used. Another specialty for
token definitions are optional pre- and suffixes which are transparently removed (after
parsing) and added (before printing) by the generated token resolvers. And last but not
least, EBNF-like productions have to be defined for each non-abstract model element
reachable from the start symbol. They have to be defined with respect to the attributes
and references of the model element and thus do not contain nonterminals in the classic
sense.
<!--l. 44--><p class="indent" >  The context menu on concrete syntax specification files offers an item to generate the actual
<span 
class="aesl-10x-x-109">resource plug-in </span>which contains the parser, printer and the editor for the language. In an
optional last step, the generated token resolvers and the printer can be tailored to specific
needs.
                                                                                     

                                                                                     
                                                                                     

                                                                                     
  <h2 class="chapterHead"><span class="titlemark">3</span>&#x00A0;&#x00A0;<a 
 id="x1-60003"></a>Concrete Syntax Specification Language (CS)</h2>
<!--l. 3--><p class="noindent" >An EMFText syntax specification must be contained in a file with the extension <span 
class="ul9r8t-x-x-95">.cs </span>and consists of
three main blocks:
     <ol  class="enumerate1" >
     <li 
  class="enumerate" id="x1-6002x1">a  configuration  block,  which  contains  the  name,  the  basemodel  and  the  root  meta
     class (startsymbol). Optionally other syntaxes and metamodels can be imported and
     generation options can be specified,
     </li>
     <li 
  class="enumerate" id="x1-6004x2">a (optional) TOKEN section. Here, tokens for the lexical analyser can be specified,
     </li>
     <li 
  class="enumerate" id="x1-6006x3">a (optional) TOKENSTYLE section. Here, the default style (color, font style) for tokens
     and keywords can be specified,
     </li>
     <li 
  class="enumerate" id="x1-6008x4">a RULES section, which defines the syntax for each concrete meta class.</li></ol>
<!--l. 17--><p class="indent" >  In the following sections we will glance at the four main blocks in more detail.
  <h3 class="sectionHead"><span class="titlemark">3.1</span>&#x00A0;&#x00A0;<a 
 id="x1-70003.1"></a>Configuration Block</h3>
<!--l. 21--><p class="noindent" >
  <h4 class="subsectionHead"><span class="titlemark">3.1.1</span>&#x00A0;&#x00A0;<a 
 id="x1-80003.1.1"></a>Required General Information</h4>
<!--l. 23--><p class="noindent" >Specify which files will contain your synax (required):
  <!--l. 25-->
  <div class="lstlisting" id="listing-1"><span class="label"><a 
 id="x1-8001r1"></a></span>SYNTAXDEF&#x00A0;fileExtension
  
  </div>
<!--l. 29--><p class="indent" >  Specify the EMF Genmodel that contains the meta classes for which the syntax will be used. The
genmodel is found using its URI.
  <!--l. 31-->
  <div class="lstlisting" id="listing-2"><span class="label"><a 
 id="x1-8002r1"></a></span>FOR&#x00A0;&#x003C;genModelURI&#x003E;&#x00A0;&#x003C;locationOfYourGenmodel&#x003E;
  
  </div>
<!--l. 35--><p class="indent" >  Giving the location of the genmodel is optional. If it is not given, EMFText searches at
two different places for the genmodel. First, in the EMF Registry, second, it looks for a
genmodel in the folder that contains your .cs file, which has the same name, but the extension
&#8217;.genmodel&#8217;.
<!--l. 38--><p class="indent" >  The root element (startsymbol) must be an element in the metamodel:
  <!--l. 40-->
  <div class="lstlisting" id="listing-3"><span class="label"><a 
 id="x1-8003r1"></a></span>START&#x00A0;nameOfAMetaClass
                                                                                     

                                                                                     
  
  </div>
<!--l. 44--><p class="indent" >  A CS specification can also have multiple root elements, which must be separated by a
comma.
<!--l. 46--><p class="noindent" >
  <h4 class="subsectionHead"><span class="titlemark">3.1.2</span>&#x00A0;&#x00A0;<a 
 id="x1-90003.1.2"></a>Importing other Models and Syntaxes</h4>
<!--l. 48--><p class="noindent" >Models and syntaxes can be imported in a dedicated import section:
  <!--l. 50-->
  <div class="lstlisting" id="listing-4"><span class="label"><a 
 id="x1-9001r1"></a></span>IMPORTS&#x00A0;{&#x00A0;<br /><span class="label"><a 
 id="x1-9002r2"></a></span>&#x00A0;&#x00A0;&#x00A0;&#x00A0;//&#x00A0;imports&#x00A0;go&#x00A0;here&#x00A0;<br /><span class="label"><a 
 id="x1-9003r3"></a></span>}
  
  </div>
<!--l. 56--><p class="indent" >  The list of imports must contain at least contain one entry. If no imports are needed the whole
section can be left out. An import entry consists of a prefix that can be used to refer imported
elements in productions, the model URI and optionally the name of a concrete syntax defined for
that model. If a syntax is imported all its rules are reused and need not to be specified in the current
CS specification.
  <!--l. 58-->
  <div class="lstlisting" id="listing-5"><span class="label"><a 
 id="x1-9004r1"></a></span>prefix&#x00A0;:&#x00A0;&#x003C;genModelURI&#x003E;&#x00A0;&#x003C;locationOfTheGenmodel&#x003E;&#x00A0;WITH&#x00A0;SYNTAX&#x00A0;syntaxURI&#x00A0;&#x003C;locationOfTheSyntax&#x003E;;
  
  </div>
<!--l. 62--><p class="indent" >  The two locations are optional.
<!--l. 64--><p class="noindent" >
  <h4 class="subsectionHead"><span class="titlemark">3.1.3</span>&#x00A0;&#x00A0;<a 
 id="x1-100003.1.3"></a>Code Generation Options</h4>
<!--l. 66--><p class="noindent" >As the imports, options are specified in a dedicated optional section:
  <!--l. 68-->
  <div class="lstlisting" id="listing-6"><span class="label"><a 
 id="x1-10001r1"></a></span>OPTIONS&#x00A0;{&#x00A0;<br /><span class="label"><a 
 id="x1-10002r2"></a></span>&#x00A0;&#x00A0;&#x00A0;&#x00A0;//&#x00A0;options&#x00A0;go&#x00A0;here&#x00A0;in&#x00A0;the&#x00A0;following&#x00A0;form:&#x00A0;<br /><span class="label"><a 
 id="x1-10003r3"></a></span>&#x00A0;&#x00A0;&#x00A0;&#x00A0;optionName&#x00A0;=&#x00A0;"optionValue";&#x00A0;<br /><span class="label"><a 
 id="x1-10004r4"></a></span>}
  
  </div>
<!--l. 75--><p class="indent" >  The list of valid options can be found in the Javadoc of the enumeration
OptionTypes<span class="footnote-mark"><a 
href="EMFTextGuide4.html#fn1x3"><sup class="textsuperscript">1</sup></a></span><a 
 id="x1-10005f1"></a> .
                                                                                     

                                                                                     
<!--l. 78--><p class="noindent" >
  <h3 class="sectionHead"><span class="titlemark">3.2</span>&#x00A0;&#x00A0;<a 
 id="x1-110003.2"></a>Tokens</h3>
<!--l. 80--><p class="noindent" >EMFText allows to specify an ordered set of token definitions. During runtime, input characters are
converted to tokens. They form the smallest unit processed by the generated parser. &#8221;Note&#8221;: By
default, EMFText implicitly uses a set of standard tokens, namingly:
     <ul class="itemize1">
     <li class="itemize">TEXT : (&#8217;A&#8217;..&#8217;Z&#8217;|&#8217;a&#8217;..&#8217;z&#8217;|&#8217;0&#8217;..&#8217;9&#8217;|&#8217;_&#8217;|&#8217;-&#8217;)+,
     </li>
     <li class="itemize">LINEBREAK : (&#8217;<br 
class="newline" />r<br 
class="newline" />n&#8217;|&#8217;<br 
class="newline" />r&#8217;|&#8217;<br 
class="newline" />n&#8217;),
     </li>
     <li class="itemize">WHITESPACE : (&#8217; &#8217;|&#8217;<br 
class="newline" />t&#8217;|&#8217;<br 
class="newline" />f&#8217;).</li></ul>
<!--l. 91--><p class="indent" >  Default tokens can be switched off using the <span 
class="ul9r8t-x-x-95">usePredefinedTokens </span>option.
<!--l. 94--><p class="noindent" >
  <h4 class="subsectionHead"><span class="titlemark">3.2.1</span>&#x00A0;&#x00A0;<a 
 id="x1-120003.2.1"></a>Simple, custom tokens</h4>
<!--l. 96--><p class="noindent" >To define custom tokens, a TOKEN section must be added to the .cs file. This section has the
following form:
  <!--l. 98-->
  <div class="lstlisting" id="listing-7"><span class="label"><a 
 id="x1-12001r1"></a></span>TOKENS&#x00A0;{&#x00A0;<br /><span class="label"><a 
 id="x1-12002r2"></a></span>&#x00A0;&#x00A0;&#x00A0;&#x00A0;//&#x00A0;token&#x00A0;definition&#x00A0;go&#x00A0;here&#x00A0;in&#x00A0;the&#x00A0;form:&#x00A0;<br /><span class="label"><a 
 id="x1-12003r3"></a></span>&#x00A0;&#x00A0;&#x00A0;&#x00A0;DEFINE&#x00A0;MY_TOKEN&#x00A0;$someRegularExpression$;&#x00A0;<br /><span class="label"><a 
 id="x1-12004r4"></a></span>}
  
  </div>
<!--l. 105--><p class="indent" >  Every token name has to start with a capital letter. A regular expression must conform to the
ANTLRv3 syntax for regular expressions without semantic annotations.
<!--l. 108--><p class="noindent" >
  <h4 class="subsectionHead"><span class="titlemark">3.2.2</span>&#x00A0;&#x00A0;<a 
 id="x1-130003.2.2"></a>Composed tokens</h4>
<!--l. 110--><p class="noindent" >Sometimes, the regular expression are quite repetitive and one wants to reuse simple expressions to
compose them to more complex ones. To do so, one can refer to other token definition by their name.
For example:
                                                                                     

                                                                                     
  <!--l. 114-->
  <div class="lstlisting" id="listing-8"><span class="label"><a 
 id="x1-13001r1"></a></span>//&#x00A0;simple&#x00A0;token&#x00A0;<br /><span class="label"><a 
 id="x1-13002r2"></a></span>DEFINE&#x00A0;CHAR&#x00A0;$(&#8217;a&#8217;..&#8217;z&#8217;|&#8217;A&#8217;..&#8217;Z&#8217;)$;&#x00A0;<br /><span class="label"><a 
 id="x1-13003r3"></a></span>//&#x00A0;simple&#x00A0;token&#x00A0;<br /><span class="label"><a 
 id="x1-13004r4"></a></span>DEFINE&#x00A0;DIGIT&#x00A0;$(&#8217;0&#8217;..&#8217;9&#8217;)$;&#x00A0;<br /><span class="label"><a 
 id="x1-13005r5"></a></span>//&#x00A0;composed&#x00A0;token&#x00A0;<br /><span class="label"><a 
 id="x1-13006r6"></a></span>DEFINE&#x00A0;IDENTIFIER&#x00A0;CHAR&#x00A0;+&#x00A0;$($&#x00A0;+&#x00A0;CHAR&#x00A0;+&#x00A0;$|$&#x00A0;+&#x00A0;DIGIT&#x00A0;+&#x00A0;$)<span 
class="cmsy-10x-x-109">*</span>$;
  
  </div>
<!--l. 123--><p class="noindent" >
  <h4 class="subsectionHead"><span class="titlemark">3.2.3</span>&#x00A0;&#x00A0;<a 
 id="x1-140003.2.3"></a>Tokens priorities</h4>
<!--l. 125--><p class="noindent" >Token definitions might be ambiguous, i.e. the languages defined for two different token may be not
disjoint. In such cases EMFText will always prefer the token defined first in the specification. By
default, the predefined tokens (TEXT, WS and LB) have lower precedence than any defined token.
However, they can be given a higher priority be redefining them before other token using the
following directive:
  <!--l. 131-->
  <div class="lstlisting" id="listing-9"><span class="label"><a 
 id="x1-14001r1"></a></span>PREDEFINED&#x00A0;nameOfPredefinedToken;
  
  </div>
<!--l. 135--><p class="noindent" >
  <h3 class="sectionHead"><span class="titlemark">3.3</span>&#x00A0;&#x00A0;<a 
 id="x1-150003.3"></a>Token Styles</h3>
<!--l. 137--><p class="noindent" >To define the default syntax highlighting for a language a special section &#8221;&#8217;TOKENSTYLES&#8221;&#8217; can be
used. For each token or keyword the color and style (BOLD, ITALIC, STRIKETHROUGH,
UNDERLINE) can be defined as follows:
  <!--l. 139-->
  <div class="lstlisting" id="listing-10"><span class="label"><a 
 id="x1-15001r1"></a></span>TOKENSTYLES&#x00A0;{&#x00A0;<br /><span class="label"><a 
 id="x1-15002r2"></a></span>&#x00A0;&#x00A0;&#x00A0;&#x00A0;//&#x00A0;show&#x00A0;MY_TOKEN&#x00A0;in&#x00A0;black&#x00A0;<br /><span class="label"><a 
 id="x1-15003r3"></a></span>&#x00A0;&#x00A0;&#x00A0;&#x00A0;"MY_TOKEN"&#x00A0;COLOR&#x00A0;#000000;&#x00A0;<br /><span class="label"><a 
 id="x1-15004r4"></a></span>&#x00A0;&#x00A0;&#x00A0;&#x00A0;//&#x00A0;show&#x00A0;keyword&#x00A0;public&#x00A0;in&#x00A0;red&#x00A0;and&#x00A0;bold&#x00A0;font&#x00A0;face&#x00A0;<br /><span class="label"><a 
 id="x1-15005r5"></a></span>&#x00A0;&#x00A0;&#x00A0;&#x00A0;"public"&#x00A0;COLOR&#x00A0;#FF0000,&#x00A0;BOLD;&#x00A0;<br /><span class="label"><a 
 id="x1-15006r6"></a></span>}
  
  </div>
<!--l. 148--><p class="noindent" >
  <h3 class="sectionHead"><span class="titlemark">3.4</span>&#x00A0;&#x00A0;<a 
 id="x1-160003.4"></a>Syntax Rules</h3>
<!--l. 150--><p class="noindent" >For each conrete meta class you can define a syntax rule. The rule specifies what the text that
represents instances of the class looks like. Rule have two sides - a left and right-hand side. The left
side denotes the name of the meta class, while the right-hand side defines the syntax
elements.
                                                                                     

                                                                                     
<!--l. 152--><p class="noindent" >
  <h4 class="subsectionHead"><span class="titlemark">3.4.1</span>&#x00A0;&#x00A0;<a 
 id="x1-170003.4.1"></a>Simple Syntax</h4>
<!--l. 154--><p class="noindent" >The most basic form of a syntax rule is:
  <!--l. 156-->
  <div class="lstlisting" id="listing-11"><span class="label"><a 
 id="x1-17001r1"></a></span>MyMetaClass&#x00A0;::=&#x00A0;someKeyword&#x00A0;;
  
  </div>
<!--l. 160--><p class="indent" >  This rule states that whenever the text "someKeyword" is found, an instance of MyMetaClass must
be created. Besides text elements that are expected "as is", parts of the syntax can be optional or
repeating. For example the syntax rule:
  <!--l. 164-->
  <div class="lstlisting" id="listing-12"><span class="label"><a 
 id="x1-17002r1"></a></span>&#x00A0;&#8217;&#8217;&#8217;MyMetaClassWithOptionalSyntax&#8217;&#8217;&#8217;&#x00A0;::=&#x00A0;("#")?&#x00A0;"someKeyword"&#x00A0;;
  
  </div>
<!--l. 168--><p class="indent" >  states the instances of MyMetaClassWithOptionalSyntax can be represented both by
"#someKeyword" and "someKeyword". Similar behavior can be definied using a star instead of a
question mark. The syntax enclosed in the paranthesis can then be repeated.
<!--l. 173--><p class="noindent" >
  <h4 class="subsectionHead"><span class="titlemark">3.4.2</span>&#x00A0;&#x00A0;<a 
 id="x1-180003.4.2"></a>Syntax for attributes</h4>
<!--l. 175--><p class="noindent" >If meta classes have attributes we can also specify syntax for the value of these attributes. To do so
simple add brackets after the name of the attribute:
  <!--l. 177-->
  <div class="lstlisting" id="listing-13"><span class="label"><a 
 id="x1-18001r1"></a></span>&#x00A0;&#8217;&#8217;&#8217;MyMetaClassWithAttributes&#8217;&#8217;&#8217;&#x00A0;::=&#x00A0;myAttribute[]&#x00A0;;
  
  </div>
<!--l. 181--><p class="indent" >  Optionally one can specify the name of a token inside the brackets. For example:
  <!--l. 183-->
  <div class="lstlisting" id="listing-14"><span class="label"><a 
 id="x1-18002r1"></a></span>&#x00A0;&#8217;&#8217;&#8217;MyMetaClassWithAttributes&#8217;&#8217;&#8217;&#x00A0;::=&#x00A0;myAttribute[MY_TOKEN]&#x00A0;;
  
  </div>
<!--l. 187--><p class="indent" >  If this name is omitted (as in the first example) EMFText uses the token TEXT, which includes
alphanumeric characters. The found text is automatically converted to the type of the attribute. If
this conversion is not successfull an error is raised when opening a file containing wrong
syntax.
                                                                                     

                                                                                     
<!--l. 189--><p class="indent" >  Another possibility to specify the token definition that shall be used to match the text for the
attribute value is do it inline. For example
  <!--l. 191-->
  <div class="lstlisting" id="listing-15"><span class="label"><a 
 id="x1-18003r1"></a></span>&#x00A0;&#8217;&#8217;&#8217;MyMetaClassWithAttributes&#8217;&#8217;&#8217;&#x00A0;::=&#x00A0;myAttribute[&#8217;(&#8217;,&#8217;)&#8217;]&#x00A0;;
  
  </div>
<!--l. 195--><p class="indent" >  can be used to express that the text for the attribute value must be enclosed in round brackets.
Between the brackets arbitrary characters (except the closing bracket) are allowed. Other characters
can be used as prefix and suffix here as well.
<!--l. 197--><p class="indent" >  By default the suffix character (in the example above this was the closing bracket) can not be
part of the text for the attribute value. To allow this an escape character needs to be
supplied:
  <!--l. 199-->
  <div class="lstlisting" id="listing-16"><span class="label"><a 
 id="x1-18004r1"></a></span>&#x00A0;&#8217;&#8217;&#8217;MyMetaClassWithAttributes&#8217;&#8217;&#8217;&#x00A0;::=&#x00A0;myAttribute[&#8217;(&#8217;,&#8217;)&#8217;,&#8217;\&#8217;]&#x00A0;;
  
  </div>
<!--l. 203--><p class="indent" >  Here the backslash can be used inside the brackets to escape the closing bracket. It must then also
be used to escape itself. For example,
  <!--l. 205-->
  <div class="lstlisting" id="listing-17"><span class="label"><a 
 id="x1-18005r1"></a></span>&#x00A0;(some&#x00A0;text&#x00A0;(some&#x00A0;more\))
  
  </div>
<!--l. 209--><p class="indent" >  yields the value
  <!--l. 211-->
  <div class="lstlisting" id="listing-18"><span class="label"><a 
 id="x1-18006r1"></a></span>&#x00A0;some&#x00A0;text&#x00A0;(somemore)
  
  </div>
<!--l. 215--><p class="noindent" >
  <h4 class="subsectionHead"><span class="titlemark">3.4.3</span>&#x00A0;&#x00A0;<a 
 id="x1-190003.4.3"></a>Syntax for references</h4>
<!--l. 217--><p class="noindent" >Meta classes can have references and consequently there is a way to specify syntax for these. EMF
distinguished between "containment" and "non-containment" references. In an EMF model, the
elements that are references with the former type are contained in the parent elements. EMFText
thus expects the syntax of the referenced elements (children) to be also contained in the parent
syntax. The latter (non-containment) references are referenced only and are contained in another
(parent) element. Analogous to the containment references, EMFText expectes the actual syntax for
those elements to be contained in the parent. The referenced elements are represented by some
                                                                                     

                                                                                     
symbolic name only.
<!--l. 219--><p class="noindent" >
  <h5 class="subsubsectionHead"><a 
 id="x1-200003.4.3"></a>Syntax for containment references</h5>
<!--l. 221--><p class="noindent" >A basic example for defining a rule for a meta class that has a containment reference look like
this:
  <!--l. 223-->
  <div class="lstlisting" id="listing-19"><span class="label"><a 
 id="x1-20001r1"></a></span>&#x00A0;&#8217;&#8217;&#8217;MyContainerMetaClass&#8217;&#8217;&#8217;&#x00A0;::=&#x00A0;"CONTAINER"&#x00A0;myContainmentReference&#x00A0;;
  
  </div>
<!--l. 227--><p class="indent" >  It allows to represent instances of MyContainerMetaClass using the keyword "CONTAINER"
followed by one instance of the type that "myContainmentReference" points to. If multiple children
need to be contained the following rule can be used:
  <!--l. 229-->
  <div class="lstlisting" id="listing-20"><span class="label"><a 
 id="x1-20002r1"></a></span>&#x00A0;&#8217;&#8217;&#8217;MyContainerMetaClass&#8217;&#8217;&#8217;&#x00A0;::=&#x00A0;"CONTAINER"&#x00A0;myContainmentReference<span 
class="cmsy-10x-x-109">*</span>&#x00A0;;
  
  </div>
<!--l. 233--><p class="indent" >  In addition, each containment reference can be restricted to allow only certain types, for
example:
  <!--l. 235-->
  <div class="lstlisting" id="listing-21"><span class="label"><a 
 id="x1-20003r1"></a></span>&#x00A0;&#8217;&#8217;&#8217;MyContainerMetaClass&#8217;&#8217;&#8217;&#x00A0;::=&#x00A0;"CONTAINER"&#x00A0;myContainmentReference&#x00A0;:&#x00A0;MySubClass&#x00A0;;
  
  </div>
<!--l. 239--><p class="indent" >  does allow only instances of "MySubClass" after the keyword "CONTAINER" even though
"myContainmentReference" may have a more general type.
<!--l. 241--><p class="noindent" >
  <h5 class="subsubsectionHead"><a 
 id="x1-210003.4.3"></a>Syntax for non-containment references</h5>
<!--l. 243--><p class="noindent" >A basic example for defining a rule for a meta class that has a non-containment reference look like
this:
  <!--l. 245-->
  <div class="lstlisting" id="listing-22"><span class="label"><a 
 id="x1-21001r1"></a></span>&#x00A0;&#8217;&#8217;&#8217;MyPointerMetaClass&#8217;&#8217;&#8217;&#x00A0;::=&#x00A0;"POINTER"&#x00A0;myNonContainmentReference[]&#x00A0;;
  
  </div>
                                                                                     

                                                                                     
<!--l. 249--><p class="indent" >  The rule is very similar to the one for containment references, but used the additional brackets
after the name of the reference. The brackets defined the token that the symbolic name must match.
In the case above, the default token (TEXT) is used. So the syntax for an example instance of class
MyPointerMetaClass can be:
  <!--l. 251-->
  <div class="lstlisting" id="listing-23"><span class="label"><a 
 id="x1-21002r1"></a></span>&#x00A0;&#8217;&#8217;POINTER&#x00A0;a&#8217;&#8217;
  
  </div>
<!--l. 255--><p class="indent" >  Since "a" is just a symbolic name that must be resolved to an actual model element, EMFText
generates a Java class that implements the interface IReferenceResolver. This class be
customized to specify how symbolic names are resolved to model elements. The default
implementation of the resolver looks for all model elements that have the correct type (the type of
"myNonContainmentReference") and that have a name or id attribute that matches the symbolic
name.
<!--l. 257--><p class="noindent" >
  <h4 class="subsectionHead"><span class="titlemark">3.4.4</span>&#x00A0;&#x00A0;<a 
 id="x1-220003.4.4"></a>Syntax for printing instructions</h4>
<!--l. 259--><p class="noindent" >To print models to text, some additional information is required by EMFText. This information
includes the numher of whitespaces and line breaks to be inserted between keywords, attribute
values, references and contained elements. If you do not want to print models to text, printing
instructions are not needed in your CS file.
<!--l. 261--><p class="noindent" >
  <h5 class="subsubsectionHead"><a 
 id="x1-230003.4.4"></a>Syntax for printing whitespace</h5>
<!--l. 263--><p class="noindent" >To explicitly print whitespace characters, the # Operator can be used:
  <!--l. 265-->
  <div class="lstlisting" id="listing-24"><span class="label"><a 
 id="x1-23001r1"></a></span>&#x00A0;&#8217;&#8217;#&#x003C;NUMBER&#x003E;&#8217;&#8217;
  
  </div>
<!--l. 269--><p class="indent" >  It is followed by a number that determines the number of whitespaces to be printed.
<!--l. 271--><p class="noindent" >
  <h5 class="subsubsectionHead"><a 
 id="x1-240003.4.4"></a>Syntax for printing line breaks</h5>
<!--l. 273--><p class="noindent" >To explicitly print line breaks, the ! Operator can be used:
                                                                                     

                                                                                     
  <!--l. 275-->
  <div class="lstlisting" id="listing-25"><span class="label"><a 
 id="x1-24001r1"></a></span>&#x00A0;&#8217;&#8217;!&#x003C;NUMBER&#x003E;&#8217;&#8217;
  
  </div>
<!--l. 279--><p class="indent" >  It is followed by a number that determines the number of tab characters that shall be printed after
the line break.
<!--l. 281--><p class="noindent" >
  <h4 class="subsectionHead"><span class="titlemark">3.4.5</span>&#x00A0;&#x00A0;<a 
 id="x1-250003.4.5"></a>Syntax for expressions</h4>
<!--l. 283--><p class="noindent" >To define syntax for metaclasses that represent expressions (e.g., binary, unary expressions
like additive or multiplicative expressions) one can use the Operator annotation. This
annotation can be added to all rules, which refer to expression metaclasses. For example, the
rule:
  <!--l. 288-->
  <div class="lstlisting" id="listing-26"><span class="label"><a 
 id="x1-25001r1"></a></span>&#x00A0;@Operator(type="binary_left_associative",&#x00A0;weight="1",&#x00A0;superclass="Expression")&#x00A0;<br /><span class="label"><a 
 id="x1-25002r2"></a></span>&#x00A0;Additive&#x00A0;::=&#x00A0;left&#x00A0;"+"&#x00A0;right;
  
  </div>
<!--l. 293--><p class="indent" >  can be used to define syntax for a metaclass "Additive". The references "left" and "right" must be
containment references and have type "Expression", which is the abstract supertype for all
metaclasses of the expression metamodel.
<!--l. 297--><p class="indent" >  The type attribute specifies the kind of expression at hand, which can be binary (either
left_associative or right_associative), unary or primitive.
<!--l. 300--><p class="indent" >  The weight attribute specified the priority of on expression type over another. For example, if a
second rule:
  <!--l. 303-->
  <div class="lstlisting" id="listing-27"><span class="label"><a 
 id="x1-25003r1"></a></span>&#x00A0;@Operator(type="binary_left_associative",&#x00A0;weight="2",&#x00A0;superclass="Expression")&#x00A0;<br /><span class="label"><a 
 id="x1-25004r2"></a></span>&#x00A0;Multiplicative&#x00A0;::=&#x00A0;left&#x00A0;"<span 
class="cmsy-10x-x-109">*</span>"&#x00A0;right;
  
  </div>
<!--l. 308--><p class="indent" >  is present, EMFText will create an expression tree, where Multiplicative nodes are created last
(i.e., multiplicative expressions take precedence over additive expressions).
<!--l. 311--><p class="indent" >  Unary expressions can be defined as follows:
  <!--l. 313-->
  <div class="lstlisting" id="listing-28"><span class="label"><a 
 id="x1-25005r1"></a></span>&#x00A0;@Operator(type="unary_prefix",&#x00A0;weight="4",&#x00A0;superclass="Expression")&#x00A0;<br /><span class="label"><a 
 id="x1-25006r2"></a></span>&#x00A0;Negation&#x00A0;::=&#x00A0;"<span 
class="cmsy-10x-x-109">-</span>"&#x00A0;body;
  
  </div>
<!--l. 318--><p class="indent" >  There is also the option to defined unary_postfix rules.
<!--l. 320--><p class="indent" >  Primitive expressions can be defined as follows:
                                                                                     

                                                                                     
  <!--l. 322-->
  <div class="lstlisting" id="listing-29"><span class="label"><a 
 id="x1-25007r1"></a></span>&#x00A0;@Operator(type="primitive",&#x00A0;weight="5",&#x00A0;superclass="Expression")&#x00A0;<br /><span class="label"><a 
 id="x1-25008r2"></a></span>&#x00A0;IntegerLiteralExp&#x00A0;::=&#x00A0;intValue[INTEGER_LITERAL];
  
  </div>
<!--l. 327--><p class="indent" >  They should be used for literals (e.g., numbers, constants or variables).
<!--l. 329--><p class="indent" >  For examples how to use the Operator rules see the SimpleMath language in the EMFText Syntax
Zoo<span class="footnote-mark"><a 
href="EMFTextGuide5.html#fn2x3"><sup class="textsuperscript">2</sup></a></span><a 
 id="x1-25009f2"></a>  and the
ThreeValuedLogic DSL<span class="footnote-mark"><a 
href="EMFTextGuide6.html#fn3x3"><sup class="textsuperscript">3</sup></a></span><a 
 id="x1-25010f3"></a> .
These do also come with an interpreter which shows how expression trees can be evaluated.
<!--l. 334--><p class="noindent" >
  <h3 class="sectionHead"><span class="titlemark">3.5</span>&#x00A0;&#x00A0;<a 
 id="x1-260003.5"></a>Suppressing warnings</h3>
<!--l. 336--><p class="noindent" >To suppress warnings issues by EMFText in <span 
class="ul9r8t-x-x-95">.cs </span>files one can use the @SuppressWarnings
annotation. This annotation can be added to rules, token definitions or complete syntax
definitions. One can either suppress all warnings or just specific types. A list of all types can be
found
<!--l. 343--><p class="indent" >  here. Please use lower camel-case syntax to specify the kind of option to suppress. For example, to
suppress warnings about features without syntax, you may use:
  <!--l. 346-->
  <div class="lstlisting" id="listing-30"><span class="label"><a 
 id="x1-26001r1"></a></span>&#x00A0;@SuppressWarnings(featureWithoutSyntax)&#x00A0;<br /><span class="label"><a 
 id="x1-26002r2"></a></span>&#x00A0;MyMetaClass&#x00A0;::=&#x00A0;"someKeyword";
  
  </div>
   
</body></html> 

                                                                                     


