\chapter{Concrete Syntax Specification Language (CS)}
\label{chap:cs}

An EMFText syntax specification must be contained in a file with the 
extension \texttt{.cs} and consists of four main blocks:

\begin{enumerate}
  \item A mandatory configuration block, which specifies the name of the syntax
        (i.e., the file extension), the generator model where to find the
        metaclasses, and the root metaclass (start symbol). Optionally, other
        syntaxes and metamodels can be imported and code generation options can
        be specified.
  \item An (optional) \texttt{TOKENS} section. Here, token types like identifiers, numbers etc.
  		 for the lexical analyser can be specified.
  \item An (optional) \texttt{TOKENSTYLES} section. Here, the default style
        (i.e., color and font style) for tokens and keywords can be specified.
  \item A \texttt{RULES} section, which defines the syntax for concrete
        metaclasses.
\end{enumerate}

In the following sections, these four main blocks will be explained in more
detail.

\section{Configuration Block}

\subsection{Required General Information}

The first required piece of information is the file extension that shall
be used for the files, which will contain your models:

\lstset{language=CS}
\begin{lstlisting}
SYNTAXDEF yourFileExtension
\end{lstlisting}

Note: The file extension must not contain the dot character.

Second, EMFText needs to know the EMF generator model (\texttt{.genmodel}) that
contains the metaclasses for which the syntax is specified. EMFText does use
the generator model rather than the Ecore model, because it requires
information about the code generated from the Ecore model (e.g., the fully
qualified names of the classes generated by the EMF). The genmodel can be referred 
to by its namespace URI: 

\lstset{language=CS}
\begin{lstlisting}
FOR <yourGenModelNamespaceURI>
\end{lstlisting}

To find the generator model with the given namespace URI, EMFText tries to 
load it from the generator model registry. If it is not registered, EMFText 
looks for a \texttt{.genmodel} file with the same name as the syntax 
definition. For example, if the syntax 
specification is contained in a file \texttt{yourdsl.cs}, EMFText looks for a
file called \texttt{yourdsl.genmodel} in the same folder.

If your genmodel is not contained in the same folder or is called differently
from the syntax file name or if you do not want to use the one in the registry, 
the optional parameter \texttt{yourGenmodelLocation} can be used: 

\lstset{language=CS}
\begin{lstlisting}
FOR <yourGenModelNamespaceURI> <yourGenmodelLocation>
\end{lstlisting}

The value of \texttt{yourGenmodelLocation} must be an URI pointing to the 
generator model. The URI can be absolute or relative to the syntax 
specification folder.
 
Third, the root element (start symbol) must be given. The root element must be
a metaclass from the metamodel:

\lstset{language=CS}
\begin{lstlisting}
START YourRootMetaClassName
\end{lstlisting}

A CS specification can also have multiple root elements, which must be separated
by a comma:

\lstset{language=CS}
\begin{lstlisting}
START RootMetaClass1, RootMetaClass2, RootMetaClass3
\end{lstlisting}

Typical candidates for root elements are metaclasses that do not have incoming 
containment edges. 

Altogether a typical header for a \texttt{.cs} file looks something like:

\lstset{language=CS}
\begin{lstlisting}
SYNTAXDEF yourFileExtension
FOR <yourGenModelNamespaceURI> <yourGenmodelLocation>
START YourRootMetaClassName
\end{lstlisting} 

\subsection{Importing other Metamodels and Syntax Specifications}
\label{sec:cs_import}
Sometimes it is required to import additional metamodels, e.g., if they are only
referenced in the current one and a syntax for some or all of its concepts
needs to be specified or reused. 
Metamodels and syntax specifications can be 
imported in a dedicated import section, which must follow after the start symbols:

\lstset{language=CS}
\begin{lstlisting}
IMPORTS {
    // imports go here
}
\end{lstlisting}

The list of imports must contain at least one entry. If no imports are 
needed the whole section must be left out. An import entry consists of a prefix, 
which can be used to refer to imported elements in rules, the metamodel
namespace URI and optionally the name of a concrete syntax defined for that
metamodel. If a syntax is imported, all its rules are reused and need not to be
specified in the current \texttt{cs} specification. Importing syntax rules is
optional. One can also just import the metamodel contained in the generator model.

\lstset{language=CS}
\begin{lstlisting}
prefix : <genModelURI> <locationOfTheGenmodel>
    // next line is optional 
    WITH SYNTAX syntaxURI <locationOfTheSyntax>
\end{lstlisting}

The two locations are again optional. For resolving the generator model the same
rules as for the ``main'' generator model (declared after the \texttt{FOR}
keyword) apply. For locating the syntax, EMFText looks up the registry of
registered syntax specifications. If no registered syntax is found, 
\texttt{locationOfTheSyntax} is used to find the \texttt{.cs} file to import.
Again, \texttt{locationOfTheSyntax} must be a relative or absolute URI.

\subsection{Code Generation Options}

EMFText's code generation can be configured using various options. These are
specified in a dedicated optional \texttt{OPTIONS} section:

\lstset{language=CS}
\begin{lstlisting}
OPTIONS {
    // options go here in the following form:
    optionName = "optionValue";
}
\end{lstlisting}

The list of valid options and their documentation can be found in
Appendix~\ref{app:options}.

\section{Tokens}
\label{sec:tokens}

EMFText allows to specify custom tokens. Each token type has a name and is
defined by a regular expression. This expression is used to convert characters 
from the DSL files to form groups (i.e., tokens). Tokens are the smallest unit
processed by the generated parser. By default, EMFText implicitly uses a set of
predefined standard tokens, namingly:

\begin{itemize}
  \item \texttt{TEXT : ('A'..'Z'|'a'..'z'|'0'..'9'|'\_'|'-')+},
  \item \texttt{LINEBREAK :
  ('\textbackslash{}r\textbackslash{}n'|'\textbackslash{}r'|'\textbackslash{}n')},
  \item \texttt{WHITESPACE : (' '|'\textbackslash{}t'|'\textbackslash{}f')}.
\end{itemize}

The predefined tokens can be explicitly excluded by using the 
\texttt{usePredefinedTokens} option:

\lstset{language=CS}
\begin{lstlisting}
OPTIONS {
    usePredefinedTokens = "false";
}
\end{lstlisting}

\subsection{Defining Custom Tokens}

To define custom tokens, a \texttt{TOKENS} section must be added to the
\texttt{.cs} file. This section has the following form:

\lstset{language=CS}
\begin{lstlisting}
TOKENS {
    // token definitions go here in the form:
    DEFINE YOUR_TOKEN_NAME $yourRegularExpression$;
}
\end{lstlisting}

Every token name has to start with a capital letter. A regular expression must
conform to the ANTLRv3 syntax for regular expressions (without semantic
annotations). However, don't worry: EMFText will complain if there is a problem
with your regular expressions, such as typos or overlaps of regular expressions.

\subsection{Composed Tokens}

Sometimes, regular expressions are quite repetitive and one wants to reuse 
simple expressions to compose them to more complex ones. To do so, one can refer 
to other token definitions by their name. For example:

\lstset{language=CS}
\begin{lstlisting}
TOKENS {
    // simple token
    DEFINE CHAR $('a'..'z'|'A'..'Z')$;
    // simple token
    DEFINE DIGIT $('0'..'9')$;
    // composed token
    DEFINE IDENTIFIER CHAR + $($ + CHAR + $|$ + DIGIT + $)*$;
}
\end{lstlisting}

If token definitions are merely used as ``helper'' tokens, they can be tagged
as \texttt{FRAGMENT}. This means the helper token itself is used in other token
definitions, but not anywhere else in the syntax specification:

\lstset{language=CS}
\begin{lstlisting}
TOKENS {
    // simple token
    DEFINE CHAR $('a'..'z'|'A'..'Z')$;
    // helper token - not used on its own
    DEFINE FRAGMENT DIGIT $('0'..'9')$;
    // composed token
    DEFINE IDENTIFIER CHAR + $($ + CHAR + $|$ + DIGIT + $)*$;
}
\end{lstlisting}

The regular expressions are composed the same way strings are composed in Java 
programs. Therefore, make sure to put parenthesis around expressions where it
is needed.

\subsection{Token Priorities}

EMFText does automatically sort token definitions. However, sometimes 
token definitions might be ambiguous (i.e., the regular expressions defined for
two different tokens are not disjoint). In such cases EMFText will always prefer
more specific tokens over more general tokens. That is, if one token definition 
includes another one, the latter is preferred over the former. If the automatic 
token sorting fails, EMFText will report an error. In this case one must turn 
off the automatic sorting using the \texttt{disableTokenSorting} option and sort 
the tokens manually. If automatic token sorting is turned off, one can give a
higher priority to imported tokens by using the following directive:

\lstset{language=CS}
\begin{lstlisting}
TOKENS {
	PRIORITIZE NameOfImportedToken;
	DEFINE SOME_CUSTOM_TOKEN $someCustomRegularExpression$;
}
\end{lstlisting}

The \texttt{PRIORITIZE} directive can also be used with the predefined tokens 
\texttt{TEXT}, \texttt{LINEBREAK} and \texttt{WHITESPACE}.

\section{Token Styles}

To define the default syntax highlighting for a language, a special section
\texttt{TOKENSTYLES} can be used. For each token or keyword the color and
style (\texttt{BOLD}, \texttt{ITALIC}, \texttt{STRIKETHROUGH},
\texttt{UNDERLINE}) can be specified as follows:

\lstset{language=CS}
\begin{lstlisting}
TOKENSTYLES {
    // show YOUR_TOKEN in black
    "YOUR_TOKEN" COLOR #000000;
    // show keyword 'public' in red and bold font face
    "public" COLOR #FF0000, BOLD;
}
\end{lstlisting}

The default highlighting can still be customized at runtime by
using the generated preference pages.

\section{Syntax Rules}

For each concrete metaclass you can define a syntax rule. The rule specifies
what the text that represents instances of the class looks like. Rules have two
sides---a left and right-hand side. The left side denotes the name of the meta
class, while the right-hand side defines the syntax elements. If you have 
imported additional metamodels you can refer to their metaclasses using the 
prefix you've defined in the import statement. For example \texttt{pre.MetaClassA} refers to 
\texttt{MetaClassA} from the metamodel with the prefix \texttt{pre}.
 
\subsection{Simple Syntax}

The most basic form of a syntax rule is:

\lstset{language=CS}
\begin{lstlisting}
YourMetaClass ::= "someKeyword" ;
\end{lstlisting}

This rule states that whenever the text \texttt{someKeyword} is found, an
instance of \texttt{YourMetaClass} must be created. Besides text elements that are
expected ``as is'', parts of the syntax can be optional or repeating. For
example the syntax rule:

\lstset{language=CS}
\begin{lstlisting}
YourMetaClassWithOptionalSyntax ::= ("#")? "someKeyword" ;
\end{lstlisting}

states that instances of \texttt{YourMetaClassWithOptionalSyntax} can be
represented both by \texttt{\#someKeyword} and \texttt{someKeyword}. Similar
behavior can be defined using a star instead of a question mark. The syntax 
enclosed in the parenthesis can then be repeated. For example,

\lstset{language=CS}
\begin{lstlisting}
YourMetaClassWithRepeatingSyntax ::= ("#")* "someKeyword" ;
\end{lstlisting}

allows to represent instances of metaclass
\texttt{YourMetaClassWithRepeatingSyntax} by writing \texttt{someKeyword},
\texttt{\#someKeyword}, \texttt{\#\#someKeyword}, or any other number of hash
symbols followed by \texttt{someKeyword}.
One can also use a plus sign instead of a star or question mark. In this case,
the syntax enclosed in the parenthesis can be repeated, but must appear at least
once.

\subsection{Syntax for EAttributes}

\subsubsection{Syntax for EAttributes Having an Arbitrary Type}

If metaclasses have attributes, we can also specify syntax for their values. 
To do so, simply add brackets after the name of the attribute:

\lstset{language=CS}
\begin{lstlisting}
YourMetaClassWithAttribute ::= yourAttribute[] ;
\end{lstlisting}

Optionally, one can specify the name of a token inside the brackets. For example:

\lstset{language=CS}
\begin{lstlisting}
YourMetaClassWithAttribute ::= yourAttribute[MY_TOKEN] ;
\end{lstlisting}

If the token name is omitted, as in the first example, EMFText uses the 
predefined token \texttt{TEXT}, which includes alphanumeric characters (see 
Sect.~\ref{sec:tokens}). The
found text is automatically converted to the type of the attribute. If this 
conversion is not successfull, an error is raised when opening a file containing 
wrong syntax. For details on customizing the conversion of tokens, see
Sect.~\ref{sec:cust_token_resolving}.

Another possibility to specify the token definition that shall be used to match 
the text for the attribute value is do it inline. For example

\lstset{language=CS}
\begin{lstlisting}
YourMetaClassWithAttribute ::= yourAttribute['(',')'] ;
\end{lstlisting}

can be used to express that the text for the value of the attribute
\texttt{yourAttribute} must be enclosed in parenthesis. Between the parenthesis 
arbitrary characters (except the closing 
parenthesis) are allowed. Other characters can be used as prefix and suffix here as 
well.

By default, the suffix character (in the example above this was the closing 
parenthesis) can not be part of the text for the attribute value. To allow this, 
an escape character needs to be supplied:

\lstset{language=CS}
\begin{lstlisting}
YourMetaClassWithAttribute ::= yourAttribute['(',')','\'] ;
\end{lstlisting}

Here the backslash can be used inside the parenthesis to escape the closing 
parenthesis. It must then also be used to escape itself. That is, one must
write two backslash characters to represent one. 

To give an example on how escaping works, consider the following text:
\texttt{(text(more\textbackslash{}))}. After parsing, this yields the attribute
value \texttt{text(more)}. The character sequence \texttt{\textbackslash{})} is
replaced by \texttt{)}. Note that the opening parenthesis does not need to be
escaped.

\subsubsection{Syntax for EAttributes of Type EBoolean}

For boolean attributes, EMFText provides a special feature to ease syntax
specification. All that is required is to give the two strings that represent
\texttt{true} and \texttt{false}. To give an example consider the following
syntax rule:

\lstset{language=CS}
\begin{lstlisting}
YourMetaClassWithAttribute ::= yourAttribute["yes" : "no"] ;
\end{lstlisting}

This rule states that \texttt{yes} represents the \texttt{true} value and
\texttt{no} represents \texttt{false}. You can also use the empty string for
one of the values:

\lstset{language=CS}
\begin{lstlisting}
YourMetaClassWithAttribute ::= yourAttribute["set" : ""] ;
\end{lstlisting}

This way, the attribute is set to \texttt{false} by default and set to
\texttt{true} in the text \texttt{set} is found.

\subsubsection{Syntax for EAttributes of Type EEnum}

For enumeration attributes, EMFText does also provide a special feature to ease
syntax specification. For each literal of the enumeration, the corresponding
string representation must be given. For example, consider the following
syntax rule:

\lstset{language=CS}
\begin{lstlisting}
YourMetaClassWithAttribute ::= 
    yourAttribute[red : "r", green : "g", blue : "b"];
\end{lstlisting}

This rule states that \texttt{r} represents the literal \texttt{red},
\texttt{g} represents the literal \texttt{green} and \texttt{b} represents the
literal \texttt{blue}. The literals of the enumeration are identified by their
name. You can also use the empty string for one of the values:

\lstset{language=CS}
\begin{lstlisting}
YourMetaClassWithAttribute ::= 
    yourAttribute[red : "r", green : "g", blue : ""] ;
\end{lstlisting}

This way, the attribute is set to \texttt{blue} by default.

\subsection{Syntax for EReferences}

Metaclasses can have references and consequently there is a way to specify 
syntax for these. EMF distinguishes between \emph{containment} and
\emph{non-containment} references. In an EMF model, the elements that are
referenced with the former type are contained in the parent elements. EMFText
thus expects the text for the contained elements (children) to be also 
contained in the parent's text. 

The latter (non-containment) references are referenced only and are contained in
another (parent) element. Thus, EMFText does not expect text that
represents the referenced element, but a symbolic identifier that refers
to the element. This is very similar to the declaration and use of variables in Java.
The declaration of a variable consists of the complete text that is required to
describe a variable (e.g., its type). In contrast, when the variable is used at
some other place it is simply referred to by its name. Non-containment
references are similar to uses of variables.

\subsubsection{Syntax for Containment References}

A basic example for defining a rule for a meta class that has a containment 
reference looks like this:

\lstset{language=CS}
\begin{lstlisting}
YourContainerMetaClass ::= "CONTAINER" yourContainmentReference ;
\end{lstlisting}

It allows to represent instances of \texttt{YourContainerMetaClass} using the
keyword \texttt{CONTAINER} followed by one instance of the type that
\texttt{yourContainmentReference} points to. If multiple children need to be
contained the following rule can be used:

\lstset{language=CS}
\begin{lstlisting}
YourContainerMetaClass ::= "CONTAINER" yourContainmentReference* ;
\end{lstlisting}

In addition, each containment reference can be restricted to allow only certain 
types, for example:

\lstset{language=CS}
\begin{lstlisting}
YourContainerMetaClass ::= "CONTAINER" 
                           yourContainmentReference : SubClass ;
\end{lstlisting}

does allow only instances of \texttt{SubClass} after the keyword
\texttt{CONTAINER} even though the reference \texttt{yourContainmentReference}
may have a more general type. One can also add multiple subclass restrictions,
which must then be separated by a comma:

\lstset{language=CS}
\begin{lstlisting}
YourContainerMetaClass ::= "CONTAINER" 
                           yourContainmentReference : SubClassA, SubClassB ;
\end{lstlisting}

\subsubsection{Syntax for Non-Containment References}

A basic example for defining a rule for a metaclass that has a non-containment 
reference looks like this:

\lstset{language=CS}
\begin{lstlisting}
YourPointerMetaClass ::= "POINTER" yourNonContainmentReference[] ;
\end{lstlisting}

The rule is very similar to the one for containment references, but uses the 
additional brackets after the name of the reference. Within the brackets 
the token that the symbolic name must match can be defined. In the case above,
the default token \texttt{TEXT} is used. Therefore, the syntax for an example
instance of class \texttt{YourPointerMetaClass} can be \texttt{POINTER a}.

Since \texttt{a} is just a symbolic name that must be resolved to an actual 
model element, EMFText generates a Java class that resolves \texttt{a} to a 
target model element. This class be customized to specify how symbolic names are
resolved to model elements. The default implementation of the resolver looks 
for all model elements that have the correct type (the type of
\texttt{yourNonContainmentReference}) and that have a
name or id attribute that matches the symbolic name. For details on how to
customize the resolving of references, see
Sect.~\ref{sec:cust_reference_resolving}.

\subsection{Syntax for Printing Instructions}

By default, EMFText can print all kinds of models. It does also preserve the
layout of the textual representation when models are parsed and printed later
on. However, to print models that have been created in memory, additional
information can be passed to EMFText to cutomize the print result. This
(optional) information includes the number of whitespaces and line breaks to be
inserted between keywords, attribute values, references and contained elements. 
If you do not want to print models to text, printing instructions are not needed 
in your \texttt{.cs} file.

\subsubsection{Syntax for Printing Whitespace}

To explicitly print whitespace characters, the \texttt{\#} operator can be used
on the right side of syntax rules:

\lstset{language=CS}
\begin{lstlisting}
YourMetaclass ::= "keyword" #2 attribute[];
\end{lstlisting}

It is followed by a number that determines the number of whitespaces to be
printed. In the example above, two whitespace characters are printed between the
keyword and the attribute value.

\subsubsection{Syntax for Printing Line Breaks}

To explicitly print line breaks, the \texttt{!} operator can be used on the
right side of syntax rules:

\lstset{language=CS}
\begin{lstlisting}
YourMetaclass ::= "keyword" !0 attribute[];
\end{lstlisting}

It is followed by a number that determines the number of tab characters that
shall be printed after the line break. In the example above, a line break
is printed after \texttt{keyword}. The number of tabs refers to the current
model element (i.e., \texttt{EObject}), which is printed. To print contained
objects with an indendation of one tab, you can use a rule like this:

\lstset{language=CS}
\begin{lstlisting}
YourMetaclass ::= "keyword" "{" (!1 containmentRef)* !0 "}";
\end{lstlisting}

Here, the first line break operator (\texttt{!1}) makes sure that all the
contained objects appear on a new line and that they are preceded by one tab
character. The second line break operator (\texttt{!0}) tells EMFText to print
the closing parenthesis (\texttt{\}}) also on a new line, but without a leading
tab.

\subsection{Syntax for Expressions}
When defining syntax for an expression language (e.g., arithmetic expressions) 
EMFText's standard mechanisms for specifying syntax can lead to structures that 
can not be optimally handled by an interpreter or evaluator. Furthermore, the 
underlying parser generator technology used by EMFText causes problems if 
left recursive rules are required to build an optimal expression tree, which is 
the case for all expression languages with left-associative binary operators 
(e.g.,~\texttt{-}). Therefore, EMFText provides a special feature called
operator precendence annotations (\texttt{@Operator}). These annotations can be
added to all rules, which refer to expression metaclasses with a common
superclass. For example, the rule:

\lstset{language=CS}
\begin{lstlisting}
@Operator(type="binary_left_associative", weight="1", superclass="Expression")
Additive ::= left "+" right;
\end{lstlisting}

defines syntax for a metaclass \texttt{Additive}. The references \texttt{left}
and \texttt{right} must be containment references and have the type
\texttt{Expression}, which is the abstract supertype for all metaclasses of the
expression metamodel.

The \texttt{type} attribute specifies the kind of expression at hand, which can
be binary (either \texttt{left\_associative} or \texttt{right\_associative}),
\texttt{unary\_prefix}, \texttt{unary\_postfix} or \texttt{primitive}.

The \texttt{weight} attribute specifies the priority of one expression type over
another. For example, if a second rule:

\lstset{language=CS}
\begin{lstlisting}
@Operator(type="binary_left_associative", weight="2", superclass="Expression")
Multiplicative ::= left "*" right;
\end{lstlisting}

is present, EMFText will create an expression tree, where
\texttt{Multiplicative} nodes are created last (i.e., multiplicative expressions 
take precedence over additive expressions).

Unary expressions can be defined as follows:

\lstset{language=CS}
\begin{lstlisting}
@Operator(type="unary_prefix", weight="4", superclass="Expression")	
Negation ::= "-" body;
\end{lstlisting}

There is also the option to define \texttt{unary\_postfix} rules.

Primitive expressions can be defined as follows:

\lstset{language=CS}
\begin{lstlisting}
@Operator(type="primitive", weight="5", superclass="Expression")
IntegerLiteralExp ::= intValue[INTEGER_LITERAL];
\end{lstlisting}

They should be used for literals (e.g., numbers, constants or variables).

One can certainly mix syntax rules that use the \texttt{@Operator} annotation
with ones that do not in the same CS specification. However, one must be careful
with the inheritance hierarchy in the metamodel in this case. All rules that
use the \texttt{@Operator} annotation must refer to a metaclass that extends the
metaclass specified with the \texttt{superclass} attribute. For subclasses of
this superclass there must not be other non-\texttt{@Operator} rules. One could
say that subtrees of the metaclass hierarchy must be either consistently
specified as \texttt{@Operator} rules or not. Mixing is not possible.

For examples how to use \texttt{@Operator} annotations see the SimpleMath
language in the EMFText Syntax
Zoo\footnote{\url{http://www.emftext.org/language/simplemath}} and the
ThreeValuedLogic
DSL\footnote{\url{http://www.emftext.org/language/threevaluedlogic}}. These do
also come with an interpreter which shows how expression trees can be evaluated.

\section{Suppressing Warnings}

To suppress warnings issued by EMFText in \texttt{.cs} files one can use the
\texttt{@SuppressWarnings} annotation. This annotation can be added to rules,
token definitions or complete syntax definitions. One can either suppress all 
warnings or just specific types. To suppress all warnings for a syntax use the
following syntax:

\lstset{language=CS}
\begin{lstlisting}
@SuppressWarnings
YourMetaClass ::= "someKeyword";
\end{lstlisting}

A list of all warning types can be found in Appendix~\ref{app:warnings}. For
example, to suppress warnings about features without syntax, you may use:

\lstset{language=CS}
\begin{lstlisting}
@SuppressWarnings(featureWithoutSyntax)
YourMetaClassWithAttribute ::= "someKeyword";
\end{lstlisting}
