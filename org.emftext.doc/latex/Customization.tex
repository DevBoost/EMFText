\chapter{DSL Customization}
\label{chap:customisation}
\section{Customization Techniques}

\subsection{Overriding Generated Classes}
\label{sec:overriding_generated_classes}
\subsection{Using Generated Extension Points}
\label{sec:using_generated_extension_points}


\section{Concrete Customizations}

\subsection{Customizing Token Resolving}
\label{sec:cust_token_resolving}

To create models from their textual representation, it is necessary to convert
the plain text found in \DSL documents to attribute values (i.e., data types).
For example, if the string \texttt{''123''} is found in a text file and shall be used as value for an
attribute which has type \texttt{EInt}, the string needs to be converted to an
\texttt{int}. Basic conversions, such as the one just mentioned, are handled by
the generated class \texttt{XyzDefaultTokenResolver} (assuming the file
extension of your \DSL is \texttt{xyz}). However, if you want to use custom data
types in your metamodels, or if you need to customize the default conversion, there
are two ways to change the conversion of text to data types.

\subsubsection{Customizing TokenResolver Classes}

The first option to customize the conversion of text, is to change the generated
token resolver classes. EMFText generates one of these classes for each token
that is defined in the \texttt{.cs} file. All classes end up in a package called
\texttt{analysis} in the \texttt{src} folder of the generated resource plug-in.

Each token resolver class has two methods---\texttt{resolve()} and
\texttt{deResolve()}. The first one is used to convert text to data types. The
second one is used to perform the other way around. Consequently,
\texttt{resolve()} is used when models are parsed, while \texttt{deResolve()} is
used to print models to text.

The default implementation for both methods delegates calls to a default token
resolver. However, this call can be replaced by custom code implementing
different behavior. The code in the \texttt{resolve()} method must convert the text
(given by the parameter \texttt{lexem}) to an object of the data type. This
object must be set using \texttt{result.setResolvedToken()}. The
\texttt{deResolve()} must implement the opposite behavior by returning a string 
representation of the object.

In the following a custom token resolver class is shown, which converts
\texttt{TEXT} tokens to \texttt{java.util.Date} objects:

\begin{lstlisting}
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Map;

import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.emftext.language.xyz.resource.xyz.IXyzTokenResolveResult;
import org.emftext.language.xyz.resource.xyz.IXyzTokenResolver;

public class XyzTEXTTokenResolver implements IXyzTokenResolver {
  
  private SimpleDateFormat format = new SimpleDateFormat("dd.MM.yyyy");
  
  public String deResolve(Object value, EStructuralFeature feature, 
      EObject container) {
    return format.format(value);
  }
  
  public void resolve(String lexem, EStructuralFeature feature, 
      IXyzTokenResolveResult result) {
    try {
      Date date = format.parse(lexem);
      result.setResolvedToken(date);
    } catch (ParseException e) {
      result.setErrorMessage(lexem + " is not a valid date.");
    }
  }
  
  public void setOptions(Map<?,?> options) {
    // can be left empty
  }
}
\end{lstlisting}

The difference between this kind of customization and the one below, is
that the implemented conversion is local w.r.t.~the textual syntax of the \DSL.
If you have multiple syntax definitions for your \DSL, each can use completely
different algorithms to convert data types.

\subsubsection{Customizing the EMF Data Type Handling}

Alternatively, you can customize the data type handling that is built into \EMF.
To do so, you need to define a custom data type in the metamodel (e.g.,
\texttt{JavaDate}). Then, the instance type name must be set to the actual Java
class, which shall be used to represent instances of the data type (e.g.,
\texttt{java.util.Date}). When running the \EMF code generation, the
\texttt{FactoryImpl} class will contain two
methods---\texttt{createJavaDateFromString()} and
\texttt{convertJavaDateToString()}. These need to be customized similar to the
token resolver class before.

The following code is a snippet from the \texttt{XyzFactoryImpl} class and shows
how to implement the same behavior as above using EMF's own data type handling
facilities.

\begin{lstlisting}
private SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd");

/**
 * <!-- begin-user-doc -->
 * <!-- end-user-doc -->
 * @generated NOT
 */
public Date createJavaDateFromString(EDataType eDataType, 
    String initialValue) {
  try {
    return format.parse(initialValue);
  } catch (ParseException e) {
    // ignore
  }
  return (Date)super.createFromString(eDataType, initialValue);
}

/**
 * <!-- begin-user-doc -->
 * <!-- end-user-doc -->
 * @generated NOT
 */
public String convertJavaDateToString(EDataType eDataType, 
    Object instanceValue) {
  return format.format(instanceValue);
}
\end{lstlisting}

\subsection{Customizing Reference Resolving}
\label{sec:cust_reference_resolving}

If metamodels expose non-containment references (i.e., \texttt{EReference}s
where the \texttt{containment} attribute is set to \texttt{false}), EMFText
needs to resolve these references. This basically means that symbolic
identifiers, which are used to reference other \texttt{EObject}s must be
replaced by actual references to the respective objects.

Thus, EMFText generates one reference resolver class for each non-containment
reference that is found in the metamodel of your \DSL and that is actually used
in the concrete syntax definition. All reference resolver classes end up in a
package called \texttt{analysis} in the \texttt{src} folder of the generated 
resource plug-in.

The default implementation delegates calls to the
\texttt{DefaultResolverDelegate} class. This class uses the following strategy
to find objects that are referenced by identifiers:

\begin{enumerate}
  \item the resource is searched for objects that have the correct type (i.e.,
  the type of the non-containment reference)
  \item if the objects having the correct type have an ID attribute, or a
  \texttt{name} attribute, or a single attribute of type \texttt{EString}, the
  value of this attribute is compared to the symbolic identifier. If the
  identifier matches the value of the attribute, the object is considered to be
  referenced.
  \item if no matching object is found and the symbolic identifier is a valid
  URI, EMFText tries to load the resource at the URI. If the resource
  contains a root object with the correct type, this object is assumed to be
  referenced.
\end{enumerate}

In cases, where this default resolving strategy is not sufficient, you can
customize the resolver classes by changing the bodies of the methods
\texttt{resolve()} and \texttt{deResolve()}. These methods are similar to the
ones generated for the token resolver classes (see
Sect.~\ref{sec:cust_token_resolving}). The first one is used to find the object
referenced by an identifier. The second one does the opposite---it creates a
symbolic identifier for a referenced object. Again, the former is used after
parsing. The latter is called when printing models.

The \texttt{resolve()} method must call \texttt{result.addMapping(identifier,
object)} to set the reference object, if one is found. The
\texttt{deResolve()} method can simply return the textual representation of the
referenced object as string.

To enable code completion for references, the \texttt{resolve()} method must be
extended to take care of the \texttt{resolveFuzzy} parameter. If this parameter is
\texttt{true}, the resolver class is used for code completion and must add all
referencable object to the result. Thus, instead of checking, whether
\texttt{identifier} actually references an object, \texttt{resolve()} can
simply add all objects that have the correct type to the result by calling
\texttt{result.addMapping()}. However, in this case, the first argument, which
is passed to \texttt{addMapping()} should not be \texttt{identifier}, but rather
the string representation of the object.

\subsection{Implementing Post Processors}
\label{sec:cust_post_processors}

\subsection{Implementing Quick Fixes}
\label{sec:cust_quick_fixes}

If a problem is added to a resource (e.g., by a post processor, cf.~Section~\ref{sec:cust_post_processors}), 
problem markers are automatically created in the editor. Markers are a convenient 
way to inspect the cause of the problem directly from the editor. By providing an 
instance of \texttt{IXyzQuickFix} while creating an \texttt{IXyzProblem}, actions 
are specified that can automatically solve the reported problem.

To implement a custom quick fix \texttt{CustomQuickFix} for a specific problem, 
\texttt{XyzQuickFix} must be subclassed. Normally, the context object (i.e., the 
object where the action is applied to) is provided as a parameter to the constructor 
of \texttt{CustomQuickFix}. The method \texttt{applyChanges()} performs the actual
fix of the problem on the context object.

This context object is also passed to the constructor of \texttt{XyzQuickFix} along
with a brief description of the quick fix and an image key that references an image 
for the quick fix. The image key is used by the \texttt{XyzImageProvider} that either
takes a key of one of the standard Eclipse images or a path to the image relative to
the UI project. In case a more sophisticated means for providing images is needed, the
\texttt{XyzImageProvider} can be manually extended after the option 
\texttt{overrideImageProvider} has been set to \texttt{false}.

The following listing shows a simple quick fix, which removes a given element from
the resource.

\begin{lstlisting}
public class RemoveElementQuickFix extends XyzQuickFix
    implements IXyzQuickFix {

  private EObject objectToRemove;

  public RemoveElementQuickFix(String message, EObject objectToRemove) {
    super(message, "IMG_ETOOL_DELETE", objectToRemove);
    this.objectToRemove = objectToRemove;
  }

  @Override
  public void applyChanges() {
    EcoreUtil.delete(objectToRemove);
  }
}
\end{lstlisting}


\subsection{Implementing Builders}
\label{sec:cust_builders}

To implement a custom builder for your \DSL, you can basically set the code
generation option \texttt{overrideBuilder} to \texttt{false}:

\begin{lstlisting}
OPTIONS {
    overrideBuilder = "false";
}
\end{lstlisting}

After regenerating the resource plug-ins (see
Sect.~\ref{sec:process_generating}), you will find a new class
\texttt{XyzBuilder} in the \texttt{src} folder of the generated resource 
plug-in (assuming the file extension of your \DSL is \texttt{xyz}). If you
face compilation errors, make sure to the delete the \texttt{XyzBuilder} 
class from the \texttt{src-gen} folder.

The generated builder class contains two methods---\texttt{isBuildingNeeded()} and
\texttt{build()}. The first one is called to let the builder decide, which
resources need to be included in the build process. The default implementation
returns \texttt{false} to avoid unnecessary loading of resources. To include all
textual resources that contain models of your \DSL, change the method to return
\texttt{true}.

The second method is called whenever the content of a resource changes. You can
implement arbitrary behavior here. Usually, builders create some kind of derived
artifact, for example a transformed or compiled version of the \DSL model. Since
\texttt{build()} retrieves the resource as method parameter, you can easily
access the contents of the resource. To save the derived artifact it is good
practice to use the URI of the original resource to derive a new URI. This can
for example be done by removing segments and adding new ones.

The following listing shows a simple builder, which copies the contents of the
resource to a new resource without making any changes.

\begin{lstlisting}
import java.io.IOException;
import java.util.Collection;

import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.core.runtime.IStatus;
import org.eclipse.core.runtime.Status;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.ecore.util.EcoreUtil;
import org.emftext.language.xyz.resource.xyz.IXyzBuilder;

public class XyzBuilder implements IXyzBuilder {
  
  public boolean isBuildingNeeded(URI uri) {
    return true;
  }
  
  public IStatus build(XyzResource resource, IProgressMonitor monitor) {
    // get contents and create copy 
    EList<EObject> contents = resource.getContents();
    Collection<EObject> contentsCopy = EcoreUtil.copyAll(contents);
    
    // create new resource with different name
    URI newUri = URI.createURI("copy.xyz").resolve(resource.getURI());
    Resource newResource = resource.getResourceSet().createResource(newUri);
    // add copy of original content to new resource
    newResource.getContents().addAll(contentsCopy);
    // save new resource
    try {
      newResource.save(null);
    } catch (IOException e) {
      // handle exception
    }
    return Status.OK_STATUS;
  }
}
\end{lstlisting}

Alternatively, you can also register builders for your \DSL in other plug-ins.

\subsection{Implementing Interpreters}
\label{sec:cust_interpreters}

To ease the implementation of interpreters for your \DSL, EMFText generates an
interpreter stub. Assuming the file extension of your \DSL is \texttt{xyz}, the
abstract stub class will be named \texttt{AbstractXyzInterpreter}. To implement
concrete interpreters, you can create subclasses of this stub class.

For each metaclass found in the metamodel of your \DSL, the interpreter
stub contains a \texttt{interprete\_Classname} method. These methods can be
overridden in concrete interpreter classes to implement the desired interpretation for the
objects of each type.

After implementing the methods for the classes which shall be interpreted, the
interpreter can be used in different modes. First, models can be interpret using
a stack. In this case, the \texttt{interprete\_Classname} methods must
perform the interpretation, but should not call other
\texttt{interprete} methods. This is automatically performed by the
interpreter. One can put objects on the interpretation stack by calling
\texttt{addObjectToInterprete()} and then start
interpretation by calling \texttt{interprete()}. Interpretation ends
when all objects from the stack are consumed.

Second, the interpretation can be performed without using the stack. In this
case, the \texttt{interprete\_Classname} methods call other
\texttt{interprete} methods to continue interpretation. The traversal of the
model is more explicit than using the interpreter with the stack in this mode.

The first, stack-based interpretation mode is useful to traverse models in a
bottom-up fashion. One can simply put all models elements (using
\texttt{eAllContents()} on the model root element) on the stack and then start
interpretation. The second, stack-independent interpretation mode is useful to
traverse models top-down.

The stub class has two type parameters---\texttt{ResultType} and
\texttt{ContextType}, which concrete subclasses must bind. The former
parameter (i.e., \texttt{ResultType}) specifies the return type of the
\texttt{interprete} methods. The latter parameter (i.e., \texttt{ContextType})
defines the type of the parameter that is passed to the \texttt{interprete}
methods. By binding the type parameters one can use arbitrary classes to pass
interpretation results.

Examples for interpreters can be found in the EMFText Syntax
Zoo. Both SimpleMath\footnote{\url{http://www.emftext.org/language/simplemath}}
and the ThreeValuedLogic
DSL\footnote{\url{http://www.emftext.org/language/threevaluedlogic}} use the
generated interpreter stubs.

\subsection{Customizing Text Hovers}

To implement custom text hovers for your \DSL, basically set the code
generation option \texttt{overrideHoverTextProvider} to \texttt{false}:

\begin{lstlisting}
OPTIONS {
    overrideHoverTextProvider = "false";
}
\end{lstlisting}

After regenerating the resource plug-ins (see
Sect.~\ref{sec:process_generating}), a new class
\texttt{XyzHoverTextProvider} can be found in the \texttt{src} folder of the
generated resource UI plug-in (assuming the file extension of your \DSL is \texttt{xyz}.
If you face compilation errors, make sure to the delete the \texttt{XyzHoverTextProvider} 
class from the \texttt{src-gen} folder.

The generated hover text provider class contains one
method---\texttt{getHoverText()}. The default implementation of this
method delegates calls to a default provider. To customize the
hover text you can inspect the \texttt{EObject} passed to the method and return arbitrary HTML code. The
following listing shows a simple customized provider, which returns the type of
the \texttt{EObject}.

\begin{lstlisting}
import org.eclipse.emf.ecore.EObject;
import org.emftext.language.xyz.resource.xyz.IXyzHoverTextProvider;

public class XyzHoverTextProvider implements IXyzHoverTextProvider {
	
  public String getHoverText(EObject object) {
    return "An object of type " + object.eClass().getName();
  }
}
\end{lstlisting}

\subsection{Customizing Code Completion Proposals}
\label{sec:cust_code_completion}

