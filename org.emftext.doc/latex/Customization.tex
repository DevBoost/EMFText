\chapter{DSL Customization}

\section{Customization Techniques}

\subsection{Overriding Generated Classes}

\subsection{Using Generated Extension Points}



\section{Concrete Customizations}

\subsection{Customizing Token Resolving}
\label{sec:cust_token_resolving}

\subsection{Customizing Reference Resolving}
\label{sec:cust_reference_resolving}

\subsection{Implementing Post Processors}

\subsection{Implementing Quick Fixes}

\subsection{Implementing Builders}

To implement a custom builder for your \DSL, basically set the code generation
option \texttt{overrideBuilder} to \texttt{false}:

\begin{lstlisting}
OPTIONS {
    overrideBuilder = "false";
}
\end{lstlisting}

After regenerating the resource plug-ins (see
Sect.~\ref{sec:process_generating}), you will find a new class
\texttt{XyzBuilder} in the \texttt{src} folder of the generated resource 
plug-in (assuming the file extension of your \DSL is \texttt{xyz}. If you
face compilation errors, make sure to the delete the \texttt{XyzBuilder} 
class from the \texttt{src-gen} folder.

The generated builder class contains two methods---\texttt{isBuildingNeeded()} and
\texttt{build()}. The first one is called to let the builder decide, which
resources need to be included in the build process. The default implementation
returns \texttt{false} to avoid unnecessary loading of resources. To include all
textual resources that contain models of your \DSL, change the method to return
\texttt{true}.

The second method is called whenever the content of a resource changes. You can
implement arbitrary behavior here. Usually, builders create some kind of derived
artifact, for example a transformed or compiled version of the \DSL model. Since
\texttt{build()} retrieves the resource as method parameter, you can easily
access the contents of the resource. To save the derived artifact it is good
practice to use the URI of the original resource to derive a new URI. This can
for example be done by removing segments and adding new ones.

The following listing shows a simple builder, which copies the contents of the
resource to a new resource without making any changes.

\begin{lstlisting}
import java.io.IOException;
import java.util.Collection;

import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.core.runtime.IStatus;
import org.eclipse.core.runtime.Status;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.ecore.util.EcoreUtil;
import org.emftext.language.xyz.resource.xyz.IXyzBuilder;

public class XyzBuilder implements IXyzBuilder {
  
  public boolean isBuildingNeeded(URI uri) {
    return true;
  }
  
  public IStatus build(XyzResource resource, IProgressMonitor monitor) {
    // get contents and create copy 
    EList<EObject> contents = resource.getContents();
    Collection<EObject> contentsCopy = EcoreUtil.copyAll(contents);
    
    // create new resource with different name
    URI newUri = URI.createURI("copy.xyz").resolve(resource.getURI());
    Resource newResource = resource.getResourceSet().createResource(newUri);
    // add copy of original content to new resource
    newResource.getContents().addAll(contentsCopy);
    // save new resource
    try {
      newResource.save(null);
    } catch (IOException e) {
      // handle exception
    }
    return Status.OK_STATUS;
  }
}
\end{lstlisting}

Alternatively, you can also register builders for your \DSL in other plug-ins.

\subsection{Implementing Interpreters}

To ease the implementation of interpreters for your \DSL, EMFText generates an
interpreter stub. Assuming the file extension of your \DSL is \texttt{xyz} the
abstract stub class will be named \texttt{AbstractXyzInterpreter}. To implement
concrete interpreters, you can create subclasses of this stub class.

For each concrete class found in the metamodel of your \DSL, the interpreter
stub contains a \texttt{interprete\_Classname} method. These methods can be
overridden in concrete interpreter classes to implement the desired interpretation for the
objects of each type.

After implementing the methods for the classes which shall be interpret, the
interpreter can be used in different modes. First, models can be interpret using
a stack. In this case, the \texttt{interprete\_Classname} methods must
perform the interpretation, but should not call other
\texttt{interprete} methods. This is automatically performed by the
interpreter. One can put objects on the interpretation stack by calling
\texttt{addObjectToInterprete()} and then start
interpretation by calling \texttt{interprete()}. Interpretation ends
when all objects from the stack are consumed.

Second, the interpretation can be performed without using the stack. In this
case, the \texttt{interprete\_Classname} methods call other
\texttt{interprete} methods to continue interpretation. The traversal of the
model is more explicit than using the interpreter with the stack in this mode.

The first, stack-based interpretation mode is useful to traverse models in a
bottom-up fashion. One can simply put all models elements (using
\texttt{eAllContents()} on the model root element) on the stack and then start
interpretation. The second, stack-independent interpretation mode is useful to
traverse models top-down.

The stub class has two type parameters---\texttt{ResultType} and
\texttt{ContextType}, which concrete subclasses must bind. The former
parameter (i.e., \texttt{ResultType}) specifies the return type of the
\texttt{interprete} methods. The latter parameter (i.e., \texttt{ContextType})
defines the type of the parameter that is passed to the \texttt{interprete}
methods. By binding the type parameters one can use arbitrary classes to pass
interpretation results.

Examples for interpreters can be found in the EMFText Syntax
Zoo. Both SimpleMath\footnote{\url{http://www.emftext.org/language/simplemath}}
and the ThreeValuedLogic
DSL\footnote{\url{http://www.emftext.org/language/threevaluedlogic}} use the
generated interpreter stubs.

\subsection{Customizing Text Hovers}

To implement custom text hovers for your \DSL, basically set the code
generation option \texttt{overrideHoverTextProvider} to \texttt{false}:

\begin{lstlisting}
OPTIONS {
    overrideHoverTextProvider = "false";
}
\end{lstlisting}

After regenerating the resource plug-ins (see
Sect.~\ref{sec:process_generating}), a new class
\texttt{XyzHoverTextProvider} can be found in the \texttt{src} folder of the
generated resource UI plug-in (assuming the file extension of your \DSL is \texttt{xyz}.
If you face compilation errors, make sure to the delete the \texttt{XyzHoverTextProvider} 
class from the \texttt{src-gen} folder.

The generated hover text provider class contains one
method---\texttt{getHoverText()}. The default implementation of this
method delegates calls to a default provider. To customize the
hover text you can inspect the \texttt{EObject} passed to the method and return arbitrary HTML code. The
following listing shows a simple customized provider, which returns the type of
the \texttt{EObject}.

\begin{lstlisting}
import org.eclipse.emf.ecore.EObject;
import org.emftext.language.xyz.resource.xyz.IXyzHoverTextProvider;

public class XyzHoverTextProvider implements IXyzHoverTextProvider {
	
  public String getHoverText(EObject object) {
    return "An object of type " + object.eClass().getName();
  }
}
\end{lstlisting}

\subsection{Customizing Code Completion Proposals}

