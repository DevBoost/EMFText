\chapter{DSL Customization}
\label{chap:customisation}
\section{Customization Techniques}

To adjust DSL plug-ins generated by EMFText to specific needs, there are three
different customization techniques. Each of the subsequent sections describes
one of them.

\subsection{Overriding Generated Artifacts}
\label{sec:overriding_generated_artifacts}

The most simple way to customize generated artifacts is to tell EMFText that it
must not override a specific class or file, which needs to be changed. For
all artifacts that are generated by EMFText there is a \texttt{override} option,
which can be set to \texttt{false} to preserve such manual changes (see
App.~\ref{app:options} for a complete list). For example, to customize the hover
text shown when the mouse arrow points at an element in the editor, the 
\texttt{overrideHoverTextProvider} must be set to \texttt{false}.

For all files that do not depend on the rules defined in the \texttt{.cs} file,
this customization technique is fine. These files do not change, if new rules
are added or existing ones are changed. Thus, manual changes will not cause
conflicts if the syntax evolves. Only when EMFText is updated and the code
generators are replaced, one may want to compare the manually adjusted files
with the ones generated by the new EMFText version to see whether all
customizations are still correct. This does particularly apply to generated
manifest files and plug-in descriptors. A list of all classes that are syntax
dependent can be found in App.~\ref{app:syndep}.

\subsection{Overriding Meta Information Classes}
\label{sec:overriding_generated_classes}

For all files that do depend on the rules defined in the \texttt{.cs} file,
another customization technique is more appropriate. Instead of setting
the \texttt{override} option to \texttt{false} for the artifact that needs to be
changed, one can set the \texttt{override} option for the meta information
classes to \texttt{false}. 

Each of the two generated resource plug-ins contains a meta information class.
These are called \texttt{XyzMetaInformation} and \texttt{XyzUIMetaInformation}.
Both classes provide factory methods to create instances of some important
classes (e.g., \texttt{createParser()} or \texttt{createPrinter()}). To
customize these classes (e.g., the printer) one can change the \texttt{create}
methods to return instances of subclasses of the original classes. By using
subclasses instead of overriding the classes directly, one can regenerate the
resource plug-ins and thereby obtain new up-to-date classes, but still make
customizations by overriding individual methods.

\subsection{Using Generated Extension Points}
\label{sec:using_generated_extension_points}

In addition to overriding generated classes---either directly or using the meta
information factory methods---one can use the extension points that are
generated by EMFText for all DSLs. Currently EMFText generates two extension 
points for each DSL---\texttt{default\_load\_options} and
\texttt{additional\_extension\_parser}.

The former can be used to customize how resources are loaded. For example, post
processors can be registered which apply changes to the models that are created
from their textual representation (see Sect.~\ref{sec:cust_post_processors}).
Also, pre processors can be registered to process the input before it is
actually passed to the parser. This is particularly useful to handle unicode
characters (see the JaMoPP implementation\footnote{\url{http://www.jamopp.org}}
for an example how to use it).

The latter extension point can be used to register additional parsers which can
handle a particular file extension. \EMF on its own does map one file extension
to one resource factory, but sometimes it is useful to have multiple
resource types for the same file extension. An example for how to use this
extension point can be found in the textual syntax for
Ecore\footnote{\url{http://www.emftext.org/index.php/EMFText_Concrete_Syntax_Zoo_Ecore}}.

\section{Concrete Customizations}

\subsection{Customizing Token Resolving}
\label{sec:cust_token_resolving}

To create models from their textual representation, it is necessary to convert
the plain text found in \DSL documents to attribute values (i.e., data types).
For example, if the string \texttt{''123''} is found in a text file and shall be used as value for an
attribute which has type \texttt{EInt}, the string needs to be converted to an
\texttt{int}. Basic conversions, such as the one just mentioned, are handled by
the generated class \texttt{XyzDefaultTokenResolver} (assuming the file
extension of your \DSL is \texttt{xyz}). However, if you want to use custom data
types in your metamodels, or if you need to customize the default conversion, there
are two ways to change the conversion of text to data types.

\subsubsection{Customizing TokenResolver Classes}

The first option to customize the conversion of text, is to change the generated
token resolver classes. EMFText generates one of these classes for each token
that is defined in the \texttt{.cs} file. All classes end up in a package called
\texttt{analysis} in the \texttt{src} folder of the generated resource plug-in.

Each token resolver class has two methods---\texttt{resolve()} and
\texttt{deResolve()}. The first one is used to convert text to data types. The
second one is used to perform the other way around. Consequently,
\texttt{resolve()} is used when models are parsed, while \texttt{deResolve()} is
used to print models to text.

The default implementation for both methods delegates calls to a default token
resolver. However, this call can be replaced by custom code implementing
different behavior. The code in the \texttt{resolve()} method must convert the text
(given by the parameter \texttt{lexem}) to an object of the data type. This
object must be set using \texttt{result.setResolvedToken()}. The
\texttt{deResolve()} must implement the opposite behavior by returning a string 
representation of the object.

In the following a custom token resolver class is shown, which converts
\texttt{TEXT} tokens to \texttt{java.util.Date} objects:

\begin{lstlisting}
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Map;

import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.emftext.language.xyz.resource.xyz.IXyzTokenResolveResult;
import org.emftext.language.xyz.resource.xyz.IXyzTokenResolver;

public class XyzTEXTTokenResolver implements IXyzTokenResolver {
  
  private SimpleDateFormat format = new SimpleDateFormat("dd.MM.yyyy");
  
  public String deResolve(Object value, EStructuralFeature feature, 
      EObject container) {
    return format.format(value);
  }
  
  public void resolve(String lexem, EStructuralFeature feature, 
      IXyzTokenResolveResult result) {
    try {
      Date date = format.parse(lexem);
      result.setResolvedToken(date);
    } catch (ParseException e) {
      result.setErrorMessage(lexem + " is not a valid date.");
    }
  }
  
  public void setOptions(Map<?,?> options) {
    // can be left empty
  }
}
\end{lstlisting}

The difference between this kind of customization and the one below, is
that the implemented conversion is local w.r.t.~the textual syntax of the \DSL.
If you have multiple syntax definitions for your \DSL, each can use completely
different algorithms to convert data types.

\subsubsection{Customizing the EMF Data Type Handling}

Alternatively, you can customize the data type handling that is built into \EMF.
To do so, you need to define a custom data type in the metamodel (e.g.,
\texttt{JavaDate}). Then, the instance type name must be set to the actual Java
class, which shall be used to represent instances of the data type (e.g.,
\texttt{java.util.Date}). When running the \EMF code generation, the
\texttt{FactoryImpl} class will contain two
methods---\texttt{createJavaDateFromString()} and
\texttt{convertJavaDateToString()}. These need to be customized similar to the
token resolver class before.

The following code is a snippet from the \texttt{XyzFactoryImpl} class and shows
how to implement the same behavior as above using EMF's own data type handling
facilities.

\begin{lstlisting}
private SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd");

/**
 * <!-- begin-user-doc -->
 * <!-- end-user-doc -->
 * @generated NOT
 */
public Date createJavaDateFromString(EDataType eDataType, 
    String initialValue) {
  try {
    return format.parse(initialValue);
  } catch (ParseException e) {
    // ignore
  }
  return (Date)super.createFromString(eDataType, initialValue);
}

/**
 * <!-- begin-user-doc -->
 * <!-- end-user-doc -->
 * @generated NOT
 */
public String convertJavaDateToString(EDataType eDataType, 
    Object instanceValue) {
  return format.format(instanceValue);
}
\end{lstlisting}

\subsection{Customizing Reference Resolving}
\label{sec:cust_reference_resolving}

If metamodels expose non-containment references (i.e., \texttt{EReference}s
where the \texttt{containment} attribute is set to \texttt{false}), EMFText
needs to resolve these references. This basically means that symbolic
identifiers, which are used to reference other \texttt{EObject}s must be
replaced by actual references to the respective objects.

Thus, EMFText generates one reference resolver class for each non-containment
reference that is found in the metamodel of your \DSL and that is actually used
in the concrete syntax definition. All reference resolver classes end up in a
package called \texttt{analysis} in the \texttt{src} folder of the generated 
resource plug-in.

The default implementation delegates calls to the
\texttt{DefaultResolverDelegate} class. This class uses the following strategy
to find objects that are referenced by identifiers:

\begin{enumerate}
  \item the resource is searched for objects that have the correct type (i.e.,
  the type of the non-containment reference)
  \item if the objects having the correct type have an ID attribute, or a
  \texttt{name} attribute, or a single attribute of type \texttt{EString}, the
  value of this attribute is compared to the symbolic identifier. If the
  identifier matches the value of the attribute, the object is considered to be
  referenced.
  \item if no matching object is found and the symbolic identifier is a valid
  URI, EMFText tries to load the resource at the URI. If the resource
  contains a root object with the correct type, this object is assumed to be
  referenced.
\end{enumerate}

In cases, where this default resolving strategy is not sufficient, you can
customize the resolver classes by changing the bodies of the methods
\texttt{resolve()} and \texttt{deResolve()}. These methods are similar to the
ones generated for the token resolver classes (see
Sect.~\ref{sec:cust_token_resolving}). The first one is used to find the object
referenced by an identifier. The second one does the opposite---it creates a
symbolic identifier for a referenced object. Again, the former is used after
parsing. The latter is called when printing models.

The \texttt{resolve()} method must call \texttt{result.addMapping(identifier,
object)} to set the referenced object, if one is found. The
\texttt{deResolve()} method can simply return the textual representation of the
referenced object as string.

To enable code completion for references, the \texttt{resolve()} method must be
extended to take care of the \texttt{resolveFuzzy} parameter. If this parameter is
\texttt{true}, the resolver class is used for code completion and must add all
referenceable object to the result. Thus, instead of checking, whether
\texttt{identifier} actually references an object, \texttt{resolve()} can
simply add all objects that have the correct type to the result by calling
\texttt{result.addMapping()}. However, in this case, the first argument, which
is passed to \texttt{addMapping()} should not be \texttt{identifier}, but rather
the string representation of the object.

\subsection{Implementing Post Processors}
\label{sec:cust_post_processors}

Another quite common customization task is to implement post processors. Post
processors basically provide the possibility to modify the model that is
created when text is parsed. This way one can add default elements which are not
represented in the model's textual representation or normalize models if
multiple concrete syntax is allowed for the same DSL concept.

Registered post processors are automatically called by the generated DSL tooling
whenever a model is created from text. This does also include the case where the
editor parses text in the background to show errors immediately. Thus, post
processors must be able to deal with partial models or explicitly abort their
execution if errors (e.g., syntactical problems) have been detected beforehand.

Post processors should not be used to solely implement semantic checks (i.e.,
to validate models). This should rather be done using the \EMF Validation
Framework as this allows checks to be available in all editors rather than a
single one that was generated by EMFText.

To register a post processor for your DSL, the generated 
\texttt{default\_load\_options} extension point must be used. This extension
point allows to register classes that provide default load options, which are
used whenever resources are loaded by the generated DSL tooling. Such classes
must implement the \texttt{IXyzOptionProvider} interface, which has one
method---\texttt{getOptions()}. To register a post processor, this method must
return a map that has an entry where the key is
\texttt{IXyzOptions.RESOURCE\_POSTPROCESSOR\_PROVIDER} and the value is an
instance of a class that implements the
\texttt{IXyzResourcePostProcessorProvider} interface. The latter object is used
by the generated DSL tooling to instantiate post processors by calling
\texttt{getResourcePostProcessor()}.

To illustrate this procedure consider the case where you want to add some
default model elements to all models that are created from text. To do so, you
need a \texttt{plugin.xml} which registers the option provider using the
following code snippet:

\begin{lstlisting}
<extension point="org.emftext.language.xyz.resource.xyz.default_load_options">
  <provider
    class="org.emftext.language.xyz.post.PostProcessorExample"
    id="org.emftext.language.xyz.post.provider1">
  </provider>
</extension>
\end{lstlisting}

This \texttt{plugin.xml} can be part of a separate plug-in (i.e., it does not
need to be part of the generated resource plug-ins). The respective post
processor class can be as follows.

\begin{lstlisting}
package org.emftext.language.xyz.post;

import java.util.Collections;
import java.util.Map;

import org.eclipse.emf.ecore.EObject;
import org.emftext.language.xyz.resource.xyz.IXyzOptionProvider;
import org.emftext.language.xyz.resource.xyz.IXyzOptions;
import org.emftext.language.xyz.resource.xyz.IXyzResourcePostProcessor;
import org.emftext.language.xyz.resource.xyz.IXyzResourcePostProcessorProvider;
import org.emftext.language.xyz.resource.xyz.mopp.XyzResource;

public class PostProcessorExample implements IXyzOptionProvider, 
  IXyzResourcePostProcessorProvider, 
  IXyzResourcePostProcessor {

  public Map<?, ?> getOptions() {
    return Collections.singletonMap(
      IXyzOptions.RESOURCE_POSTPROCESSOR_PROVIDER, 
      this
    );
  }

  public IXyzResourcePostProcessor getResourcePostProcessor() {
    return this;
  }

  public void process(XyzResource resource) {
    EObject root = resource.getContents().get(0);
    // perform model modifications here
  }
}
\end{lstlisting}

One can see that this class implements all three interfaces that are required to
register a post processor. The actual post processing must be implemented in the
\texttt{process()} method. Here, the model can be modified in arbitrary ways.
However, one must be aware that any modification will yield different textual
representations when the model is printed.

\subsection{Implementing Quick Fixes}
\label{sec:cust_quick_fixes}

If a problem is added to a resource (e.g., by a post processor, cf.~Section~\ref{sec:cust_post_processors}), 
problem markers are automatically created in the editor. Markers are a convenient 
way to inspect the cause of the problem directly from the editor. By providing an 
instance of \texttt{IXyzQuickFix} while creating an \texttt{IXyzProblem}, actions 
are specified that can automatically solve the reported problem.

To implement a custom quick fix \texttt{CustomQuickFix} for a specific problem, 
\texttt{XyzQuickFix} must be subclassed. Normally, the context object (i.e., the 
object where the action is applied to) is provided as a parameter to the constructor 
of \texttt{CustomQuickFix}. The method \texttt{applyChanges()} performs the actual
fix of the problem on the context object.

This context object is also passed to the constructor of \texttt{XyzQuickFix} along
with a brief description of the quick fix and an image key that references an image 
for the quick fix. The image key is used by the \texttt{XyzImageProvider} that either
takes a key of one of the standard Eclipse images or a path to the image relative to
the UI project. In case a more sophisticated means for providing images is needed, the
\texttt{XyzImageProvider} can be manually extended after the option 
\texttt{overrideImageProvider} has been set to \texttt{false}.

The following listing shows a simple quick fix, which removes a given element from
the resource.

\begin{lstlisting}
public class RemoveElementQuickFix extends XyzQuickFix
    implements IXyzQuickFix {

  private EObject objectToRemove;

  public RemoveElementQuickFix(String message, EObject objectToRemove) {
    super(message, "IMG_ETOOL_DELETE", objectToRemove);
    this.objectToRemove = objectToRemove;
  }

  @Override
  public void applyChanges() {
    EcoreUtil.delete(objectToRemove);
  }
}
\end{lstlisting}


\subsection{Implementing Builders}
\label{sec:cust_builders}

To implement a custom builder for your \DSL, you can basically set the code
generation option \texttt{overrideBuilder} to \texttt{false}:

\begin{lstlisting}
OPTIONS {
    overrideBuilder = "false";
}
\end{lstlisting}

After regenerating the resource plug-ins (see
Sect.~\ref{sec:process_generating}), you will find a new class
\texttt{XyzBuilder} in the \texttt{src} folder of the generated resource 
plug-in (assuming the file extension of your \DSL is \texttt{xyz}). If you
face compilation errors, make sure to the delete the \texttt{XyzBuilder} 
class from the \texttt{src-gen} folder.

The generated builder class contains two methods---\texttt{isBuildingNeeded()} and
\texttt{build()}. The first one is called to let the builder decide, which
resources need to be included in the build process. The default implementation
returns \texttt{false} to avoid unnecessary loading of resources. To include all
textual resources that contain models of your \DSL, change the method to return
\texttt{true}.

The second method is called whenever the content of a resource changes. You can
implement arbitrary behavior here. Usually, builders create some kind of derived
artifact, for example a transformed or compiled version of the \DSL model. Since
\texttt{build()} retrieves the resource as method parameter, you can easily
access the contents of the resource. To save the derived artifact it is good
practice to use the URI of the original resource to derive a new URI. This can
for example be done by removing segments and adding new ones.

The following listing shows a simple builder, which copies the contents of the
resource to a new resource without making any changes.

\begin{lstlisting}
import java.io.IOException;
import java.util.Collection;

import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.core.runtime.IStatus;
import org.eclipse.core.runtime.Status;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.ecore.util.EcoreUtil;
import org.emftext.language.xyz.resource.xyz.IXyzBuilder;

public class XyzBuilder implements IXyzBuilder {
  
  public boolean isBuildingNeeded(URI uri) {
    return true;
  }
  
  public IStatus build(XyzResource resource, IProgressMonitor monitor) {
    // get contents and create copy 
    EList<EObject> contents = resource.getContents();
    Collection<EObject> contentsCopy = EcoreUtil.copyAll(contents);
    
    // create new resource with different name
    URI newUri = URI.createURI("copy.xyz").resolve(resource.getURI());
    Resource newResource = resource.getResourceSet().createResource(newUri);
    // add copy of original content to new resource
    newResource.getContents().addAll(contentsCopy);
    // save new resource
    try {
      newResource.save(null);
    } catch (IOException e) {
      // handle exception
    }
    return Status.OK_STATUS;
  }
}
\end{lstlisting}

Alternatively, you can also register builders for your \DSL in other plug-ins.

\subsection{Implementing Interpreters}
\label{sec:cust_interpreters}

To ease the implementation of interpreters for your \DSL, EMFText generates an
interpreter stub. Assuming the file extension of your \DSL is \texttt{xyz}, the
abstract stub class will be named \texttt{AbstractXyzInterpreter}. To implement
concrete interpreters, you can create subclasses of this stub class.

For each metaclass found in the metamodel of your \DSL, the interpreter
stub contains a \texttt{interprete\_Classname} method. These methods can be
overridden in concrete interpreter classes to implement the desired interpretation for the
objects of each type.

After implementing the methods for the classes which shall be interpreted, the
interpreter can be used in different modes. First, models can be interpret using
a stack. In this case, the \texttt{interprete\_Classname} methods must
perform the interpretation, but should not call other
\texttt{interprete} methods. This is automatically performed by the
interpreter. One can put objects on the interpretation stack by calling
\texttt{addObjectToInterprete()} and then start
interpretation by calling \texttt{interprete()}. Interpretation ends
when all objects from the stack are consumed.

Second, the interpretation can be performed without using the stack. In this
case, the \texttt{interprete\_Classname} methods call other
\texttt{interprete} methods to continue interpretation. The traversal of the
model is more explicit than using the interpreter with the stack in this mode.

The first, stack-based interpretation mode is useful to traverse models in a
bottom-up fashion. One can simply put all models elements (using
\texttt{eAllContents()} on the model root element) on the stack and then start
interpretation. The second, stack-independent interpretation mode is useful to
traverse models top-down.

The interpreter stub class has two type parameters---\texttt{ResultType} and
\texttt{ContextType}, which concrete subclasses must bind. The former
parameter (i.e., \texttt{ResultType}) specifies the return type of the
\texttt{interprete} methods. The latter parameter (i.e., \texttt{ContextType})
defines the type of the parameter that is passed to the \texttt{interprete}
methods. By binding the type parameters one can use arbitrary classes to pass
interpretation results.

Examples for interpreters can be found in the EMFText Syntax
Zoo. Both SimpleMath\footnote{\url{http://www.emftext.org/language/simplemath}}
and the ThreeValuedLogic
DSL\footnote{\url{http://www.emftext.org/language/threevaluedlogic}} use the
generated interpreter stubs.

\subsection{Customizing Text Hovers}

To implement custom text hovers for your \DSL, basically set the code
generation option \texttt{overrideHoverTextProvider} to \texttt{false}:

\begin{lstlisting}
OPTIONS {
    overrideHoverTextProvider = "false";
}
\end{lstlisting}

After regenerating the resource plug-ins (see
Sect.~\ref{sec:process_generating}), a new class
\texttt{XyzHoverTextProvider} can be found in the \texttt{src} folder of the
generated resource UI plug-in (assuming the file extension of your \DSL is \texttt{xyz}).
If you face compilation errors, make sure to the delete the \texttt{XyzHoverTextProvider} 
class from the \texttt{src-gen} folder.

The generated hover text provider class contains one
method---\texttt{getHoverText()}. The default implementation of this
method delegates calls to a default provider. To customize the
hover text you can inspect the \texttt{EObject} passed to the method and return arbitrary HTML code. The
following listing shows a simple customized provider, which returns the type of
the \texttt{EObject}.

\begin{lstlisting}
import org.eclipse.emf.ecore.EObject;
import org.emftext.language.xyz.resource.xyz.IXyzHoverTextProvider;

public class XyzHoverTextProvider implements IXyzHoverTextProvider {
	
  public String getHoverText(EObject object) {
    return "An object of type " + object.eClass().getName();
  }
}
\end{lstlisting}

\subsection{Customizing Code Completion Proposals}
\label{sec:cust_code_completion}

The DSL tooling generated by EMFText does equip the DSL editor with default code
completion facilities. If you find the completion proposols to be not
sufficient, or you want to adjust them w.r.t.~the text that is displayed for
specific proposals or the icons that are shown, you can customize the proposals.
To do so, set the \texttt{overrideProposalPostProcessor} option to \texttt{false}. 
After regenerating the resource plug-ins, you will find a class
\texttt{XyzProposalPostProcessor} in the \texttt{src} folder of the UI resource
plug-in. The class with the same name in the \texttt{src-gen} folder can then be
deleted.

The default implementation of the only method in this class (i.e.,
\texttt{process()}) does return the list of proposals as they are. However, you
can make arbitrary changes to this list. For example, you can remove proposals
if you find them not useful or modify proposals if you want to change the
displayed string or icon. You can also add new proposals if needed.

The proposals that are passed to the \texttt{process()} method provide 
information such as which structural feature they complete
(\texttt{getStructuralFeature()}), which image they are associated with
(\texttt{getImage()}) or which text is inserted if the respective proposal is
selected by a user (\texttt{getInsertString()}). To modify proposals, new
instances of the \texttt{XyzCompletionProposal} must be created, because this 
class is immutable.
