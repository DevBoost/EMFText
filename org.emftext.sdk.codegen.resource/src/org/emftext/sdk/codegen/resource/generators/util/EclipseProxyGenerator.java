package org.emftext.sdk.codegen.resource.generators.util;

import static org.emftext.sdk.codegen.resource.generators.IClassNameConstants.COLLECTION;
import static org.emftext.sdk.codegen.resource.generators.IClassNameConstants.CORE_EXCEPTION;
import static org.emftext.sdk.codegen.resource.generators.IClassNameConstants.I_CONFIGURATION_ELEMENT;
import static org.emftext.sdk.codegen.resource.generators.IClassNameConstants.I_EXTENSION_REGISTRY;
import static org.emftext.sdk.codegen.resource.generators.IClassNameConstants.MAP;
import static org.emftext.sdk.codegen.resource.generators.IClassNameConstants.PLATFORM;

import org.emftext.sdk.codegen.composites.JavaComposite;
import org.emftext.sdk.codegen.parameters.ArtifactParameter;
import org.emftext.sdk.codegen.resource.GenerationContext;
import org.emftext.sdk.codegen.resource.generators.JavaBaseGenerator;

public class EclipseProxyGenerator extends JavaBaseGenerator<ArtifactParameter<GenerationContext>> {

	@Override
	public void generateJavaContents(JavaComposite sc) {
		
		sc.add("package " + getResourcePackageName() + ";");
		sc.addLineBreak();
		
		sc.addJavadoc(
			"A utility class that bundles all dependencies to the Eclipse platform. " +
			"Client of this class must check whether the Eclipse bundles are available " +
			"in the classpath. If they are not available, this call is not used, which " +
			"allows to run resource plug-in that are generated by EMFText in stand-alone mode."
		);
		sc.add("public class " + getResourceClassName() + " {");
		sc.addLineBreak();
		addMethods(sc);
		sc.add("}");
	}

	private void addMethods(JavaComposite sc) {
		sc.add("public void getDefaultLoadOptionProviderExtensions(" + MAP + "<Object, Object> optionsMap) {");
		sc.add("if (" + PLATFORM + ".isRunning()) {");
		sc.addComment("find default load option providers");
		sc.add(I_EXTENSION_REGISTRY + " extensionRegistry = " + PLATFORM
				+ ".getExtensionRegistry();");
		sc.add(I_CONFIGURATION_ELEMENT
				+ " configurationElements[] = extensionRegistry.getConfigurationElementsFor("
				+ pluginActivatorClassName + ".EP_DEFAULT_LOAD_OPTIONS_ID);");
		sc.add("for (" + I_CONFIGURATION_ELEMENT
				+ " element : configurationElements) {");
		sc.add("try {");
		sc.add(iOptionProviderClassName + " provider = ("
				+ iOptionProviderClassName
				+ ") element.createExecutableExtension(\"class\");");
		sc.add("final " + MAP + "<?, ?> options = provider.getOptions();");
		sc.add("final " + COLLECTION + "<?> keys = options.keySet();");
		sc.add("for (Object key : keys) {");
		sc.add(mapUtilClassName +  ".putAndMergeKeys(optionsMap, key, options.get(key));");
		sc.add("}");
		sc.add("} catch (" + CORE_EXCEPTION + " ce) {");
		sc.add(pluginActivatorClassName
				+ ".logError(\"Exception while getting default options.\", ce);");
		sc.add("}");
		sc.add("}");
		sc.add("}");
		sc.add("}");
		sc.addLineBreak();
	}
}
