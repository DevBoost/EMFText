<?xml version="1.0" encoding="UTF-8"?>
 <chapter version="5.0" xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:m="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
    <title>Introduction</title>

    <para>EMFTextEdit is a tool which allows users to define a plain textual
    syntax for Ecore based metamodels and to generate components to load,
    edit and store model instances. The syntax is specified by a so called
    concrete syntax specification which are usually stored as files with the
    suffix <db:emphasis>cs</db:emphasis>. A <db:emphasis>cs</db:emphasis>specification is directly related to one ore more Ecore
    metamodel(s) whose structure implicitly pretends a grammar skeleton. The
    following figure gives an overview on how the generator part of
    EMFTextEdit works and what components it actually generates.</para>

    <figure>
      <title>EMFTextEdit Generation Artifacts</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/emftext_schema.png" version=""></imagedata>
        </imageobject>
      </mediaobject>
    </figure>

    <para>Through combining metamodel and cs specification, EMFTextEdit
    derives a context-free grammar and exports it as an ANTLR parser
    specification. This specification contains annotated semantic actions
    which cover the largest part of metamodel instantiation. EMFTextEdit then
    transparently delegates parser and lexer generation to ANTLR by passing
    the generated grammar file. Since ANTLR does not cover the whole class of
    context-free grammars we can not guarantee the generation of a working
    parser for arbitrary cases. However, in most cases generation should be
    sufficient.</para>

    <para>While parsers are used to load model instances from textual
    representations a printer is needed to do the inverse, e.g. to print an
    in-memory instance of the metamodel back to a textual representation. The
    printed results then should again be parseable by the corresponding
    parser. Both instances (printed and loaded) should be equal. Furthermore,
    printers should produce a formatted and human-readable output. The
    EMFTextEdit built-in printer generator tries to achieve these goals by
    interpreting the cs file and the derived grammar. <db:emphasis>specifications</db:emphasis>  can be
    enriched by special operators to indicate that on a specific position
    white-spaces or newlines have to be printed. Additionally, it uses
    information about literals (e.g. keywords) in defined languages which are
    removed from model instances. As for parser generation, EMFTextEdit does
    not guarantee that printer generation works for arbitrary cases but mostly
    it is be a convenient solution.</para>

    <para>EMFTextEdit also generates a set of resolvers. Resolvers convert
    parsed token strings to an adequate representation in the metamodel
    instance.</para>

    <para>TokenResolvers implement a mapping from the string value of a
    specific token to a native Java type (e.g. boolean, int, String etc.). In
    the standard implementation TokenResolvers can automatically remove and
    add (printing) pre- and suffixes. The conversion to native Java data types
    is done by delegation to the corresponding Java type conversion functions.
    For example, Integer.parseInt("42") results in an int valued 42. Since
    this behavior is only desirable for concrete syntaxes mirroring exactly
    (or at least partially) the Java syntax for primitive types, users are
    expected to implement more adequate mapping functions as needed.</para>

    <para>Resolvments depending on context are meant to be realised by
    implementing ProxyResolvers. For these only stubs are generated. While
    TokenResolvers are directly invoked by parsers, ProxyResolvers come into
    play during an additional tree analysis phase. A TreeAnalyser iterates
    over the tree and invokes resolvers if necessary until it reaches a
    fix-point. In the base implementation a simple name analysis is performed.
    An additional feature is the evaluation of eventually annotated OCL
    constraints. With OCL, consistency conditions can be declared on the
    metamodel to further improve quality of EMFTextEdit based
    developments.</para>
  </chapter>
