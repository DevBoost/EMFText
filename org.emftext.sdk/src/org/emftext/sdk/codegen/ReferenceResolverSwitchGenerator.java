package org.emftext.sdk.codegen;

import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.List;

import org.eclipse.emf.codegen.ecore.genmodel.GenClass;
import org.eclipse.emf.codegen.ecore.genmodel.GenFeature;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.emftext.runtime.resource.IReferenceResolverSwitch;
import org.emftext.runtime.resource.IReferenceResolveResult;

/**
 * A generator that creates a multiplexing reference resolver.
 * Depending on the type of the reference that must be resolved,
 * the generated class delegates the resolve call to the appropriate
 * reference resolver.
 */
public class ReferenceResolverSwitchGenerator extends BaseGenerator {
	
	private final GenerationContext context;
	
	/**
	 * 
	 * 
	 * @param context
	 */
	public ReferenceResolverSwitchGenerator(GenerationContext context) {
		super(context.getPackageName(), context.getReferenceResolverSwitchClassName());
		this.context = context;
	}
	
	@Override
	public boolean generate(PrintWriter out) {
		out.print(generateReferenceResolverSwitch());
		return true;
	}
	
	 /**
     * Generates the reference resolver switch that calls the correct
     * reference resolvers generated by <code>generateReferenceResolver()</code>.
     */
    private String generateReferenceResolverSwitch()  {  
    	StringBuffer s = new StringBuffer();
        s.append("package " + getResourcePackageName() + "; \n\n");
        
		s.append("public class " + getResourceClassName() + " implements " + IReferenceResolverSwitch.class.getName() + " {\n\n");
		
		generateFields(s);
		generateResolveMethod(s);
		generateResolveStrictMethod(s);   
		generateDeResolveMethod(s);   
        generateSetOptionsMethod(s);
		generateResolveFuzzyMethod(s);
		
		s.append("}\n");
		
    	return s.toString();	
    }

	private void generateResolveFuzzyMethod(StringBuffer s) {
		s.append("\tpublic void resolveFuzzy(" + String.class.getName() + " identifier, " + EObject.class.getName() + " container, int position, " + IReferenceResolveResult.class.getName() + " result) {\n");
		for (GenFeature proxyReference : context.getNonContainmentReferences()) {
			GenClass genClass = proxyReference.getGenClass();
			String accessorName = genClass.getGenPackage().getQualifiedPackageInterfaceName() + ".eINSTANCE.get"  + genClass.getName() + "()";
			String generatedClassName = context.getReferenceResolverClassName(proxyReference);
			// TODO we should use the featureID constant instead of the integer value
			int featureID = genClass.getEcoreClass().getEStructuralFeature(proxyReference.getName()).getFeatureID();
			s.append("\n\t\tif (" + accessorName+ ".isInstance(container)) {");
			s.append("\n\t\t\torg.eclipse.emf.ecore.EStructuralFeature feature = container.eClass().getEStructuralFeature(" + featureID + ");");
			s.append("\n\t\t\tif (feature instanceof org.eclipse.emf.ecore.EReference) {");
			s.append("\n\t\t\t\t" + low(generatedClassName) + ".resolve(identifier, (" + genClass.getQualifiedInterfaceName() + ") container, (org.eclipse.emf.ecore.EReference) feature, position, true, result);");
			s.append("\n\t\t\t}");
			s.append("\n\t\t}\n");
		}
		s.append("\t}\n\n");
	}

	private void generateSetOptionsMethod(StringBuffer s) {
		s.append("\tpublic void setOptions(" + java.util.Map.class.getName() + "<?, ?> options) {\n");
		for (GenFeature proxyReference : context.getNonContainmentReferences()) {
			String generatedClassName = context.getReferenceResolverClassName(proxyReference);
			s.append("\t\t" + low(generatedClassName) + ".setOptions(options);\n");			
		}
		s.append("\t}\n\n");
	}

	private void generateDeResolveMethod(StringBuffer s) {
		s.append("\tpublic " + String.class.getName() + " deResolve(" + EObject.class.getName() + " refObject, " + EObject.class.getName() + " container, " + EReference.class.getName() + " reference) {\n");
		for(GenFeature proxyReference : context.getNonContainmentReferences()) {
			String generatedClassName = context.getReferenceResolverClassName(proxyReference);
			String genClassName = proxyReference.getGenClass().getQualifiedInterfaceName();
			// TODO we should use the featureID constant instead of the integer value
			int featureID = proxyReference.getGenClass().getEcoreClass().getEStructuralFeature(proxyReference.getName()).getFeatureID();
			s.append("\t\tif (container instanceof " + genClassName + " && reference.getFeatureID() == " + featureID + ") {\n");		
			s.append("\t\t\treturn " + low(generatedClassName)+".deResolve(refObject, (" + genClassName + ") container, reference);\n");			
			s.append("\t\t}\n");
		}
		s.append("\t\treturn null;\n");
		s.append("\t}\n\n");
	}

	private void generateResolveStrictMethod(StringBuffer s) {
		s.append("\tpublic void resolveStrict(" + String.class.getName() + " identifier, " + EObject.class.getName() + " container, " + EReference.class.getName() + " reference, int position, " + IReferenceResolveResult.class.getName() + " result) {\n");		
		for(GenFeature proxyReference : context.getNonContainmentReferences()) {
			String generatedClassName = context.getReferenceResolverClassName(proxyReference);
			GenClass genClass = proxyReference.getGenClass();
			final int featureID = genClass.getEcoreClass().getEStructuralFeature(proxyReference.getName()).getFeatureID();
			// TODO we should use the featureID constant instead of the integer value
			final String genClassName = genClass.getQualifiedInterfaceName();
			s.append("\t\tif (container instanceof " + genClassName + " && reference.getFeatureID() == " + featureID + ") {\n");		
			s.append("\t\t\t" + low(generatedClassName) + ".resolve(identifier, (" + genClassName + ") container, reference, position, false, result);\n");
			s.append("\t\t\treturn;\n");
			s.append("\t\t}\n");			
		}
		s.append("\t}\n\n");
	}

	private void generateResolveMethod(StringBuffer s) {
		s.append("\tpublic void resolve(" + String.class.getName() + " identifier, " + EObject.class.getName() + " container, " + EReference.class.getName() + " reference, int position, boolean resolveFuzzy, " + IReferenceResolveResult.class.getName() + " result) {\n");
		s.append("\t\tif (resolveFuzzy) {\n");
		s.append("\t\t\tresolveFuzzy(identifier, container, position, result);\n");
		s.append("\t\t} else {\n");
		s.append("\t\t\tresolveStrict(identifier, container, reference, position, result);\n");
		s.append("\t\t}\n");
		s.append("\t}\n\n");
	}

	private void generateFields(StringBuffer s) {
    	List<String> generatedResolvers = new ArrayList<String>();

		for(GenFeature proxyReference : context.getNonContainmentReferences()) {
			String generatedClassName = context.getReferenceResolverClassName(proxyReference);
			if (!generatedResolvers.contains(generatedClassName)) {
				generatedResolvers.add(generatedClassName);
				String fullClassName = context.getResolverPackageName(proxyReference) + "." + generatedClassName;
				s.append("\tprotected " + fullClassName + " " + low(generatedClassName) + " = new " + fullClassName + "();\n\n");			
			}
		}
	}
}
