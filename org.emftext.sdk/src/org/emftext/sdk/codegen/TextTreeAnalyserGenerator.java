package org.emftext.sdk.codegen;

import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import org.eclipse.emf.codegen.ecore.genmodel.GenClass;
import org.eclipse.emf.codegen.ecore.genmodel.GenFeature;
import org.eclipse.emf.codegen.ecore.genmodel.GenPackage;
import org.eclipse.emf.common.util.BasicEList;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.emftext.runtime.resource.ReferenceResolver;
import org.emftext.runtime.resource.ResolveResult;
import org.emftext.runtime.resource.impl.EMFTextTreeAnalyserImpl;

public class TextTreeAnalyserGenerator extends BaseGenerator {
	
	private String resolverImplementationPackage;
	private Map<GenFeature, String> proxyReferences;
	
	/**
	 * 
	 * 
	 * @param proxyReferences - a Map which contains all GenFeatures which where referenced and 
	 * a mapping to the corresponding resolver class which was generated.
	 * @param analyserPackageName
	 * @param analyserClassName
	 * @param resolverImplementationPackage
	 */
	
	public TextTreeAnalyserGenerator(Map<GenFeature, String> proxyReferences, String analyserClassName, String analyserPackageName, String resolverImplementationPackage){
		super(analyserClassName,analyserPackageName);
		this.resolverImplementationPackage = resolverImplementationPackage;
		this.proxyReferences = proxyReferences;
	}
	
	@Override
	public boolean generate(PrintWriter out) {
		out.print(generateTreeAnalyser(proxyReferences));
		return true;
	}
	
	 /**
     * Generates the tree analyser that searches the output of the parser for proxies and calls the corresponding
     * reference resolvers generated by <code>generateReferenceResolver()</code>.
     */
    protected String generateTreeAnalyser(Map<GenFeature, String> proxyReferences)  {  
    	List<String> generatedResolvers = new ArrayList<String>();
    	StringBuffer s = new StringBuffer();
     	
        s.append("package " + super.getResourcePackageName() + "; \n\n");

        s.append("import org.eclipse.emf.ecore.EObject;\n");
        s.append("import org.eclipse.emf.ecore.EReference;\n\n");
        
        //import required EClasses
        EList<GenClass> importedClasses = new BasicEList<GenClass>();
        for(GenFeature proxyReference : proxyReferences.keySet()) {
        	GenClass genClass = proxyReference.getGenClass();
        	GenPackage p = genClass.getGenPackage();
        	String base = p.getBasePackage() == null ? "" : (p.getBasePackage() +".");
        	String classImport =  base + p.getEcorePackage().getName() + "." + genClass.getName();
            if (!importedClasses.contains(genClass)) {
            	s.append("import "+ classImport + ";\n");
            	importedClasses.add(genClass);
            }
        }

        if (!proxyReferences.isEmpty()) s.append("import " + resolverImplementationPackage + ".*;\n\n");
		
		s.append("public class " + super.getResourceClassName() + " extends " + EMFTextTreeAnalyserImpl.class.getName() + " {\n\n");
		
		for(GenFeature proxyReference : proxyReferences.keySet()) {
			String generatedClassName = proxyReferences.get(proxyReference);
			if (!generatedResolvers.contains(generatedClassName)) {
				generatedResolvers.add(generatedClassName);
				s.append("\tprotected " + generatedClassName + " " + low(generatedClassName) + " = new " + generatedClassName + "();\n\n");			
			}
		}
		
		s.append("\tpublic void resolve(String identifier, EObject container, EReference reference, int position, boolean resolveFuzzy, " + ResolveResult.class.getName() + " result) {\n");
		s.append("\t\tif (resolveFuzzy) {\n");
		s.append("\t\t\tresolveFuzzy(identifier, container, position, result);\n");
		s.append("\t\t} else {\n");
		s.append("\t\t\tresolveStrict(identifier, container, reference, position, result);\n");
		s.append("\t\t}\n");
		s.append("\t}\n\n");

		s.append("\tpublic void resolveStrict(String identifier, EObject container, EReference reference, int position, " + ResolveResult.class.getName() + " result) {\n");		
		for(GenFeature proxyReference : proxyReferences.keySet()) {
			String generatedClassName = proxyReferences.get(proxyReference);
			final int featureID = proxyReference.getGenClass().getEcoreClass().getEStructuralFeature(proxyReference.getName()).getFeatureID();
			// TODO we should use the featureID constant instead of the integer value
			s.append("\t\tif (container instanceof " + proxyReference.getGenClass().getName() + " && reference.getFeatureID() == " + featureID + ") {\n");		
			s.append("\t\t\t" + low(generatedClassName) + ".resolve(identifier, container, reference, position, false, result);\n");
			s.append("\t\t\treturn;\n");
			s.append("\t\t}\n");			
		}
		s.append("\t}\n\n");   
        
		s.append("\tpublic String deResolve(EObject refObject, EObject container, EReference reference) {\n");
		for(GenFeature proxyReference : proxyReferences.keySet()) {
			String generatedClassName = proxyReferences.get(proxyReference);
			String genClassName = proxyReference.getGenClass().getName();
			// TODO we should use the featureID constant instead of the integer value
			int featureID = proxyReference.getGenClass().getEcoreClass().getEStructuralFeature(proxyReference.getName()).getFeatureID();
			s.append("\t\tif (container instanceof " + genClassName + " && reference.getFeatureID() == " + featureID + ") {\n");		
			s.append("\t\t\treturn " + low(generatedClassName)+".deResolve(refObject,container,reference);\n");			
			s.append("\t\t}\n");			
		}
		s.append("\t\treturn null;\n");
		s.append("\t}\n\n");   
        
        s.append("\tpublic void setOptions(java.util.Map<?, ?> options) {\n");
		for(GenFeature proxyReference : proxyReferences.keySet()) {
			String generatedClassName = proxyReferences.get(proxyReference);
			s.append("\t\t" + low(generatedClassName) + ".setOptions(options);\n");			
		}
		s.append("\t}\n\n");
		
		s.append("\tpublic void resolveFuzzy(java.lang.String identifier, EObject container, int position, " + ResolveResult.class.getName() + " result) {\n\n");
		for(GenFeature proxyReference : proxyReferences.keySet()) {
			String genClassName = proxyReference.getGenClass().getName();
			String generatedClassName = proxyReferences.get(proxyReference);
			// TODO we should use the featureID constant instead of the integer value
			int featureID = proxyReference.getGenClass().getEcoreClass().getEStructuralFeature(proxyReference.getName()).getFeatureID();
			s.append("\t\tresolveFuzzy(" + genClassName + ".class, identifier, container, position, " + featureID + ", " + low(generatedClassName) + ", result);\n");
		}
		s.append("\t}\n\n");
		
		s.append("\tprotected void resolveFuzzy(Class<?> clazz, String identifier, EObject container, int position, \n");
		s.append("\t\t\tint featureID, \n");
		s.append("\t\t\t" + ReferenceResolver.class.getName() + " resolver, " + ResolveResult.class.getName() + " result\n");
		s.append("\t\t\t) {\n");
		s.append("\n");
		s.append("\t\t//if (clazz.isInstance(container)) {\n"); //TODO @mseifert this should be activated and use the reflective API (EClass)
		s.append("\t\t\t" + EStructuralFeature.class.getName() + " feature = container.eClass().getEStructuralFeature(featureID);\n");
		s.append("\t\t\tif (!(feature instanceof EReference)) {\n");
		s.append("\t\t\t\treturn;\n");
		s.append("\t\t\t}\n");
		s.append("\t\t\tresolver.resolve(identifier, container, (EReference) feature, position, true, result);\n");
		s.append("\t}\n");
		s.append("\n");
		
		s.append("}\n");
		
    	return s.toString();	
    }
}
