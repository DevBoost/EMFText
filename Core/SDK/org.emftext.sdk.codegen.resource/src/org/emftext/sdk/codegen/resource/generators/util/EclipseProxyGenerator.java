/*******************************************************************************
 * Copyright (c) 2006-2014
 * Software Technology Group, Dresden University of Technology
 * DevBoost GmbH, Berlin, Amtsgericht Charlottenburg, HRB 140026
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 * 
 * Contributors:
 *   Software Technology Group - TU Dresden, Germany;
 *   DevBoost GmbH - Berlin, Germany
 *      - initial API and implementation
 ******************************************************************************/
package org.emftext.sdk.codegen.resource.generators.util;

import static de.devboost.codecomposers.java.ClassNameConstants.ARRAY_LIST;
import static de.devboost.codecomposers.java.ClassNameConstants.ITERATOR;
import static de.devboost.codecomposers.java.ClassNameConstants.LIST;
import static de.devboost.codecomposers.java.ClassNameConstants.MAP;
import static de.devboost.codecomposers.java.ClassNameConstants.SET;
import static org.emftext.sdk.codegen.resource.generators.ClassNameConstants.COLLECTION;
import static org.emftext.sdk.codegen.resource.generators.ClassNameConstants.CONSTRAINT_STATUS;
import static org.emftext.sdk.codegen.resource.generators.ClassNameConstants.CORE_EXCEPTION;
import static org.emftext.sdk.codegen.resource.generators.ClassNameConstants.EMF_MODEL_VALIDATION_PLUGIN;
import static org.emftext.sdk.codegen.resource.generators.ClassNameConstants.EVALUATION_MODE;
import static org.emftext.sdk.codegen.resource.generators.ClassNameConstants.E_NOTIFICATION_IMPL;
import static org.emftext.sdk.codegen.resource.generators.ClassNameConstants.E_OBJECT;
import static org.emftext.sdk.codegen.resource.generators.ClassNameConstants.INTERNAL_E_OBJECT;
import static org.emftext.sdk.codegen.resource.generators.ClassNameConstants.I_BATCH_VALIDATOR;
import static org.emftext.sdk.codegen.resource.generators.ClassNameConstants.I_CONFIGURATION_ELEMENT;
import static org.emftext.sdk.codegen.resource.generators.ClassNameConstants.I_EXTENSION_REGISTRY;
import static org.emftext.sdk.codegen.resource.generators.ClassNameConstants.I_FILE;
import static org.emftext.sdk.codegen.resource.generators.ClassNameConstants.I_LIVE_VALIDATOR;
import static org.emftext.sdk.codegen.resource.generators.ClassNameConstants.I_RESOURCE;
import static org.emftext.sdk.codegen.resource.generators.ClassNameConstants.I_STATUS;
import static org.emftext.sdk.codegen.resource.generators.ClassNameConstants.I_WORKSPACE;
import static org.emftext.sdk.codegen.resource.generators.ClassNameConstants.I_WORKSPACE_ROOT;
import static org.emftext.sdk.codegen.resource.generators.ClassNameConstants.MODEL_VALIDATION_SERVICE;
import static org.emftext.sdk.codegen.resource.generators.ClassNameConstants.NOTIFICATION;
import static org.emftext.sdk.codegen.resource.generators.ClassNameConstants.PATH;
import static org.emftext.sdk.codegen.resource.generators.ClassNameConstants.PLATFORM;
import static org.emftext.sdk.codegen.resource.generators.ClassNameConstants.RESOURCE;
import static org.emftext.sdk.codegen.resource.generators.ClassNameConstants.RESOURCES_PLUGIN;
import static org.emftext.sdk.codegen.resource.generators.ClassNameConstants.RESOURCE_FACTORY;
import static org.emftext.sdk.codegen.resource.generators.ClassNameConstants.RESOURCE_SET;
import static org.emftext.sdk.codegen.resource.generators.ClassNameConstants.RESOURCE_SET_IMPL;
import static org.emftext.sdk.codegen.resource.generators.ClassNameConstants.URI;

import org.emftext.sdk.OptionManager;
import org.emftext.sdk.codegen.annotations.SyntaxDependent;
import org.emftext.sdk.codegen.parameters.ArtifactParameter;
import org.emftext.sdk.codegen.resource.GenerationContext;
import org.emftext.sdk.codegen.resource.generators.EProblemTypeGenerator;
import org.emftext.sdk.codegen.resource.generators.JavaBaseGenerator;
import org.emftext.sdk.concretesyntax.OptionTypes;

import de.devboost.codecomposers.java.JavaComposite;

@SyntaxDependent
public class EclipseProxyGenerator extends JavaBaseGenerator<ArtifactParameter<GenerationContext>> {

	@Override
	public void generateJavaContents(JavaComposite sc) {
		
		sc.add("package " + getResourcePackageName() + ";");sc.addLineBreak();sc.addImportsPlaceholder();
		sc.addLineBreak();
		
		sc.addJavadoc(
			"A utility class that bundles all dependencies to the Eclipse platform. " +
			"Clients of this class must check whether the Eclipse bundles are available " +
			"in the classpath. If they are not available, this class is not used, which " +
			"allows to run resource plug-in that are generated by EMFText in stand-alone mode. " +
			"In this case the EMF JARs are sufficient to parse and print resources."
		);
		sc.add("public class " + getResourceClassName() + " {");
		sc.addLineBreak();
		OptionTypes option = OptionTypes.REMOVE_ECLIPSE_DEPENDENT_CODE;
		boolean removeEclipseDependentCode = OptionManager.INSTANCE.getBooleanOptionValue(getContext().getConcreteSyntax(), option);
		if (!removeEclipseDependentCode) {
			addMethods(sc);
		} else {
			sc.addComment("This class is intentionally left empty because option '" + option.getLiteral() + "' is set to true.");
		}
		sc.add("}");
	}

	private void addMethods(JavaComposite sc) {
		addGetDefaultLoadOptionProviderExtensionsMethod(sc);
		addGetResourceFactoryExtensionsMethod(sc);
		addGetResourceMethod(sc);
		addGetFileForResourceMethod(sc);
		addGetFileForURIMethod(sc);
		addCheckEMFValidationConstraintsMethod(sc);
		addCreateNotificationsMethod(sc);
		addCreateNotificationMethod(sc);
		addAddStatusMethod(sc);
		addGetPlatformResourceEncodingMethod(sc);
	}

	private void addGetFileForResourceMethod(JavaComposite sc) {
		sc.addJavadoc("Returns the file that contains the given resource.");
		sc.add("public " + I_FILE(sc) + " getFileForResource(" + RESOURCE(sc) + " resource) {");
		sc.add("return getFileForURI(resource.getURI());");
		sc.add("}");
		sc.addLineBreak();
	}

	private void addGetFileForURIMethod(JavaComposite sc) {
		sc.addJavadoc(
			"Returns the file that corresponds to the given URI. If the URI " +
			"does not correspond to a file (e.g., because it is not a platform " + 
			"URI or because it is <code>null</code>), <code>null</code> is " +
			"returned."
		);
		sc.add("public " + I_FILE(sc) + " getFileForURI(" + URI(sc) + " uri) {");
		sc.add("if (uri == null) {");
		sc.add("return null;");
		sc.add("}");
		sc.add(I_WORKSPACE(sc) + " workspace = " + RESOURCES_PLUGIN(sc) + ".getWorkspace();");
		sc.add(I_WORKSPACE_ROOT(sc) + " workspaceRoot = workspace.getRoot();");
		sc.add("String platformString = uri.toPlatformString(true);");
		sc.addComment("If the URI is not a platform URI, we cannot determine the file.");
		sc.add("if (platformString == null) {");
		sc.add("return null;");
		sc.add("}");
		sc.add(PATH(sc) + " path = new " + PATH(sc) + "(platformString);");
		sc.add("return workspaceRoot.getFile(path);");
		sc.add("}");
		sc.addLineBreak();
	}

	private void addCreateNotificationMethod(JavaComposite sc) {
		sc.add("private void createNotification(" + E_OBJECT(sc) + " eObject, " + LIST(sc) + "<" + NOTIFICATION(sc) + "> notifications) {");
		sc.add("if (eObject instanceof " + INTERNAL_E_OBJECT(sc) + ") {");
		sc.add(INTERNAL_E_OBJECT(sc) + " internalEObject = (" + INTERNAL_E_OBJECT(sc) + ") eObject;");
		sc.add(NOTIFICATION(sc) + " notification = new " + E_NOTIFICATION_IMPL(sc) + "(internalEObject, 0, " + E_NOTIFICATION_IMPL(sc) + ".NO_FEATURE_ID, null, null);");
		sc.add("notifications.add(notification);");
		sc.add("}");
		sc.add("}");
		sc.addLineBreak();
	}

	private void addCreateNotificationsMethod(JavaComposite sc) {
		sc.add("private " + COLLECTION(sc) + "<" + NOTIFICATION(sc) + "> createNotifications(" + E_OBJECT(sc) + " eObject) {");
		sc.add(LIST(sc) + "<" + NOTIFICATION(sc) + "> notifications = new " + ARRAY_LIST(sc) + "<" + NOTIFICATION(sc) + ">();");
		sc.add("createNotification(eObject, notifications);");
		sc.add(ITERATOR(sc) + "<" + E_OBJECT(sc) + "> allContents = eObject.eAllContents();");
		sc.add("while (allContents.hasNext()) {");
		sc.add(E_OBJECT(sc) + " next = (" + E_OBJECT(sc) + ") allContents.next();");
		sc.add("createNotification(next, notifications);");
		sc.add("}");
		sc.add("return notifications;");
		sc.add("}");
		sc.addLineBreak();
	}

	private void addGetResourceFactoryExtensionsMethod(JavaComposite sc) {
		sc.addJavadoc(
			"Adds all registered resource factory extensions to the given map. " +
			"Such extensions can be used to register multiple resource factories " +
			"for the same file extension."
		);
    	sc.add("public void getResourceFactoryExtensions(" + MAP(sc) + "<String, " + RESOURCE_FACTORY(sc) + "> factories) {");
     	sc.add("if (" + PLATFORM(sc) + ".isRunning()) {");
    	sc.add(I_EXTENSION_REGISTRY(sc) + " extensionRegistry = " + PLATFORM(sc) + ".getExtensionRegistry();");
    	sc.add(I_CONFIGURATION_ELEMENT(sc) + " configurationElements[] = extensionRegistry.getConfigurationElementsFor(" + pluginActivatorClassName + ".EP_ADDITIONAL_EXTENSION_PARSER_ID);");
    	sc.add("for (" + I_CONFIGURATION_ELEMENT(sc) + " element : configurationElements) {");
    	sc.add("try {");
    	sc.add("String type = element.getAttribute(\"type\");");
    	sc.add(RESOURCE(sc) +".Factory factory = (" + RESOURCE(sc) + ".Factory) element.createExecutableExtension(\"class\");");
    	sc.add("if (type == null) {");
    	sc.add("type = \"\";");
    	sc.add("}");
    	sc.add(RESOURCE(sc) + ".Factory otherFactory = factories.get(type);");
		sc.add("if (otherFactory != null) {");
		sc.add("Class<?> superClass = factory.getClass().getSuperclass();");
		sc.add("while(superClass != Object.class) {");
		sc.add("if (superClass.equals(otherFactory.getClass())) {");
		sc.add("factories.put(type, factory);");
		sc.add("break;");
		sc.add("}");
		sc.add("superClass = superClass.getClass();");
		sc.add("}");
		sc.add("}");
		sc.add("else {");
		sc.add("factories.put(type, factory);");
		sc.add("}");
    	sc.add("} catch (" + CORE_EXCEPTION(sc) + " ce) {");
    	sc.add("new " + runtimeUtilClassName + "().logError(\"Exception while getting default options.\", ce);");
    	sc.add("}");
    	sc.add("}");
    	sc.add("}");
    	sc.add("}");
    	sc.addLineBreak();
	}

	private void addGetDefaultLoadOptionProviderExtensionsMethod(JavaComposite sc) {
		sc.addJavadoc(
			"Adds all registered load option provider extension to the given map. " +
			"Load option providers can be used to set default options for loading resources " +
			"(e.g. input stream pre-processors)."
		);
		sc.add("public void getDefaultLoadOptionProviderExtensions(" + MAP(sc) + "<Object, Object> optionsMap) {");
		sc.add("if (" + PLATFORM(sc) + ".isRunning()) {");
		sc.addComment("find default load option providers");
		sc.add(I_EXTENSION_REGISTRY(sc) + " extensionRegistry = " + PLATFORM(sc)
				+ ".getExtensionRegistry();");
		sc.add(I_CONFIGURATION_ELEMENT(sc)
				+ " configurationElements[] = extensionRegistry.getConfigurationElementsFor("
				+ pluginActivatorClassName + ".EP_DEFAULT_LOAD_OPTIONS_ID);");
		sc.add("for (" + I_CONFIGURATION_ELEMENT(sc)
				+ " element : configurationElements) {");
		sc.add("try {");
		sc.add(iOptionProviderClassName + " provider = ("
				+ iOptionProviderClassName
				+ ") element.createExecutableExtension(\"class\");");
		sc.add("final " + MAP(sc) + "<?, ?> options = provider.getOptions();");
		sc.add("final " + COLLECTION(sc) + "<?> keys = options.keySet();");
		sc.add("for (Object key : keys) {");
		sc.add(mapUtilClassName +  ".putAndMergeKeys(optionsMap, key, options.get(key));");
		sc.add("}");
		sc.add("} catch (" + CORE_EXCEPTION(sc) + " ce) {");
		sc.add("new " + runtimeUtilClassName + "().logError(\"Exception while getting default options.\", ce);");
		sc.add("}");
		sc.add("}");
		sc.add("}");
		sc.add("}");
		sc.addLineBreak();
	}

	private void addGetResourceMethod(JavaComposite sc) {
		sc.addJavadoc("Gets the resource that is contained in the give file.");
		sc.add("public " + textResourceClassName + " getResource(" + I_FILE(sc) + " file) {");
		sc.add(RESOURCE_SET(sc) + " rs = new " + RESOURCE_SET_IMPL(sc) + "();");
		sc.add(RESOURCE(sc) + " resource = rs.getResource(" + URI(sc) + ".createPlatformResourceURI(file.getFullPath().toString(), true), true);");
		sc.add("return (" + textResourceClassName + ") resource;");
		sc.add("}");
		sc.addLineBreak();
	}

	private void addCheckEMFValidationConstraintsMethod(JavaComposite sc) {
		sc.addJavadoc(
			"Checks all registered EMF validation constraints. " +
			"Note: EMF validation does not work if OSGi is not running.");
		sc.add("@SuppressWarnings(\"restriction\")");
		sc.add("public void checkEMFValidationConstraints(" + iTextResourceClassName + " resource, " + E_OBJECT(sc) + " root, boolean includeBatchConstraints) {");
		sc.addComment("The EMF validation framework code throws a NPE if the validation plug-in is not loaded. "
				+ "This is a bug, which is fixed in the Helios release. Nonetheless, we need to catch the "
				+ "exception here.");
		sc.add(runtimeUtilClassName + " runtimeUtil = new " + runtimeUtilClassName + "();");
		sc.add("if (runtimeUtil.isEclipsePlatformRunning() && runtimeUtil.isEMFValidationAvailable()) {");
		sc.addComment("The EMF validation framework code throws a NPE if the validation plug-in is not loaded. "
				+ "This is a workaround for bug 322079.");
		// We use the fully qualified name for the EMFModelValidationPlugin
		// because an import would cause a warning.
		sc.add("if (" + EMF_MODEL_VALIDATION_PLUGIN(null) + ".getPlugin() != null) {");
		sc.add("try {");
		sc.add(MODEL_VALIDATION_SERVICE(sc) + " service = " + MODEL_VALIDATION_SERVICE(sc) + ".getInstance();");
		sc.add(I_STATUS(sc) + " status;");
		sc.addComment("Batch constraints are only evaluated if requested (e.g., when a resource is loaded for the first time).");
		sc.add("if (includeBatchConstraints) {");
		sc.add(I_BATCH_VALIDATOR(sc) + " validator = service.<" + E_OBJECT(sc) + ", " + I_BATCH_VALIDATOR(sc) + ">newValidator(" + EVALUATION_MODE(sc) + ".BATCH);");
		sc.add("validator.setIncludeLiveConstraints(false);");
		sc.add("status = validator.validate(root);");
		sc.add("addStatus(status, resource, root, " + eProblemTypeClassName + "." + EProblemTypeGenerator.PROBLEM_TYPES.BATCH_CONSTRAINT_PROBLEM.name() + ");");
		sc.add("}");
		sc.addComment("Live constraints are always evaluated");
		sc.add(I_LIVE_VALIDATOR(sc) + " validator = service.<" + NOTIFICATION(sc) + ", " + I_LIVE_VALIDATOR(sc) + ">newValidator(" + EVALUATION_MODE(sc) + ".LIVE);");
		sc.add(COLLECTION(sc) + "<" + NOTIFICATION(sc) + "> notifications = createNotifications(root);");
		sc.add("status = validator.validate(notifications);");
		sc.add("addStatus(status, resource, root, " + eProblemTypeClassName + "." + EProblemTypeGenerator.PROBLEM_TYPES.LIVE_CONSTRAINT_PROBLEM.name() + ");");
		sc.add("} catch (Throwable t) {");
		sc.add("new " + runtimeUtilClassName + "().logError(\"Exception while checking contraints provided by EMF validator classes.\", t);");
		sc.add("}");
		sc.add("}");
		sc.add("}");
		sc.add("}");
		sc.addLineBreak();
	}
	
	private void addAddStatusMethod(JavaComposite sc) {
		sc.add("public void addStatus(" + I_STATUS(sc) + " status, " + 
				iTextResourceClassName + " resource, " + E_OBJECT(sc) + " root, " +
				eProblemTypeClassName + " problemType) {");
		sc.add(LIST(sc) + "<" + E_OBJECT(sc) + "> causes = new " + ARRAY_LIST(sc) + "<"
				+ E_OBJECT(sc) + ">();");
		sc.add("causes.add(root);");
		sc.add("if (status instanceof " + CONSTRAINT_STATUS(sc) + ") {");
		sc.add(CONSTRAINT_STATUS(sc) + " constraintStatus = (" + CONSTRAINT_STATUS(sc)
				+ ") status;");
		sc.add(SET(sc) + "<" + E_OBJECT(sc)
				+ "> resultLocus = constraintStatus.getResultLocus();");
		sc.add("causes.clear();");
		sc.add("causes.addAll(resultLocus);");
		sc.add("}");
		sc.add(I_STATUS(sc) + "[] children = status.getChildren();");
		sc.add("boolean hasChildren = children != null && children.length > 0;");
		sc.addComment("Ignore composite status objects that have children. "
				+ "The actual status information is then contained in the child objects.");
		sc.add("if (!status.isMultiStatus() || !hasChildren) {");
		sc.add("int severity = status.getSeverity();");
		sc.add("if (severity == " + I_STATUS(sc) + ".ERROR) {");
		sc.add("for (" + E_OBJECT(sc) + " cause : causes) {");
		sc.add("resource.addError(status.getMessage(), problemType, cause);");
		sc.add("}");
		sc.add("}");
		sc.add("if (severity == " + I_STATUS(sc) + ".WARNING) {");
		sc.add("for (" + E_OBJECT(sc) + " cause : causes) {");
		sc.add("resource.addWarning(status.getMessage(), problemType, cause);");
		sc.add("}");
		sc.add("}");
		sc.add("}");
		sc.add("if (children != null) {");
		sc.add("for (" + I_STATUS(sc) + " child : children) {");
		sc.add("addStatus(child, resource, root, problemType);");
		sc.add("}");
		sc.add("}");
		sc.add("}");
		sc.addLineBreak();
	}
	
	private void addGetPlatformResourceEncodingMethod(JavaComposite sc) {
		sc.addJavadoc(
			"Returns the encoding for this resource that is specified in the " +
			"workspace file properties or determined by the default workspace " +
			"encoding in Eclipse."
		);
		sc.add("public String getPlatformResourceEncoding(" + URI(sc) +" uri) {");
		sc.addComment("We can't determine the encoding if the platform is not running.");
		sc.add("if (!new " + runtimeUtilClassName + "().isEclipsePlatformRunning()) {");
		sc.add("return null;");
		sc.add("}");
		sc.add("if (uri != null && uri.isPlatform()) {");
		sc.add("String platformString = uri.toPlatformString(true);");
		sc.add(I_RESOURCE(sc) + " platformResource = " + RESOURCES_PLUGIN(sc) + ".getWorkspace().getRoot().findMember(platformString);");
		sc.add("if (platformResource instanceof " + I_FILE(sc) + ") {");
		sc.add(I_FILE(sc) + " file = (" + I_FILE(sc) + ") platformResource;");
		sc.add("try {");
		sc.add("return file.getCharset();");
		sc.add("} catch (" + CORE_EXCEPTION(sc) + " ce) {");
		sc.add("new " + runtimeUtilClassName + "().logWarning(\"Could not determine encoding of platform resource: \" + uri.toString(), ce);");
		sc.add("}");
		sc.add("}");
		sc.add("}");
		sc.add("return null;");
		sc.add("}");
		sc.addLineBreak();
	}

}
