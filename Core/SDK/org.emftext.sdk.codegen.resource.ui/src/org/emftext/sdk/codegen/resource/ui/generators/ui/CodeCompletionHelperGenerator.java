/*******************************************************************************
 * Copyright (c) 2006-2014
 * Software Technology Group, Dresden University of Technology
 * DevBoost GmbH, Berlin, Amtsgericht Charlottenburg, HRB 140026
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 * 
 * Contributors:
 *   Software Technology Group - TU Dresden, Germany;
 *   DevBoost GmbH - Berlin, Germany
 *      - initial API and implementation
 ******************************************************************************/
package org.emftext.sdk.codegen.resource.ui.generators.ui;

import static de.devboost.codecomposers.java.ClassNameConstants.LINKED_HASH_MAP;
import static de.devboost.codecomposers.java.ClassNameConstants.LINKED_HASH_SET;
import static de.devboost.codecomposers.java.ClassNameConstants.LIST;
import static de.devboost.codecomposers.java.ClassNameConstants.MAP;
import static org.emftext.sdk.codegen.resource.ClassNameConstants.ARRAYS;
import static org.emftext.sdk.codegen.resource.ClassNameConstants.BYTE_ARRAY_INPUT_STREAM;
import static org.emftext.sdk.codegen.resource.ClassNameConstants.COLLECTION;
import static org.emftext.sdk.codegen.resource.ClassNameConstants.COLLECTIONS;
import static org.emftext.sdk.codegen.resource.ClassNameConstants.E_ATTRIBUTE;
import static org.emftext.sdk.codegen.resource.ClassNameConstants.E_CLASS;
import static org.emftext.sdk.codegen.resource.ClassNameConstants.E_CLASSIFIER;
import static org.emftext.sdk.codegen.resource.ClassNameConstants.E_ENUM;
import static org.emftext.sdk.codegen.resource.ClassNameConstants.E_ENUM_LITERAL;
import static org.emftext.sdk.codegen.resource.ClassNameConstants.E_OBJECT;
import static org.emftext.sdk.codegen.resource.ClassNameConstants.E_REFERENCE;
import static org.emftext.sdk.codegen.resource.ClassNameConstants.E_STRUCTURAL_FEATURE;
import static org.emftext.sdk.codegen.resource.ClassNameConstants.PLATFORM;
import static org.emftext.sdk.codegen.resource.ClassNameConstants.RESOURCE_SET;
import static org.emftext.sdk.codegen.resource.ClassNameConstants.RESOURCE_SET_IMPL;
import static org.emftext.sdk.codegen.resource.ui.UIClassNameConstants.ADAPTER_FACTORY_LABEL_PROVIDER;
import static org.emftext.sdk.codegen.resource.ui.UIClassNameConstants.ARRAY_LIST;
import static org.emftext.sdk.codegen.resource.ui.UIClassNameConstants.IMAGE;

import org.emftext.sdk.codegen.parameters.ArtifactParameter;
import org.emftext.sdk.codegen.resource.GenerationContext;
import org.emftext.sdk.codegen.resource.ui.UIGeneratorUtil;
import org.emftext.sdk.codegen.resource.ui.generators.UIJavaBaseGenerator;

import de.devboost.codecomposers.StringComposite;
import de.devboost.codecomposers.java.JavaComposite;

public class CodeCompletionHelperGenerator extends UIJavaBaseGenerator<ArtifactParameter<GenerationContext>> {

	/**
	 * This is a temporary flag which can be used to enable the generation of
	 * debug output. This flag must be removed once all code completion issues
	 * have been resolved.
	 */
	public static final boolean INSERT_DEBUG_OUTPUT_CODE = false;

	private final UIGeneratorUtil generatorUtil = new UIGeneratorUtil();

	@Override
	public void generateJavaContents(JavaComposite sc) {
		
		sc.add("package " + getResourcePackageName() + ";");
		sc.addLineBreak();
		sc.addImportsPlaceholder();
		sc.addLineBreak();
		
		sc.addJavadoc(
			"A CodeCompletionHelper can be used to derive completion proposals for partial " +
			"documents. It runs the parser generated by EMFText in a special mode (i.e., the " +
			"rememberExpectedElements mode). Based on the elements that are expected by the " +
			"parser for different regions in the document, valid proposals are computed."
		);
		sc.add("public class " + getResourceClassName() + " {");
		sc.addLineBreak();
		addFields(sc);
		addMethods(sc);
		sc.add("}");
	}

	private void addFields(StringComposite sc) {
		sc.add("private " + attributeValueProviderClassName + " attributeValueProvider = new " + attributeValueProviderClassName + "();");
		sc.addLineBreak();
		sc.add("private " + iMetaInformationClassName + " metaInformation = new " + metaInformationClassName + "();");
		sc.addLineBreak();
	}

	private void addMethods(JavaComposite sc) {
		addComputeCompletionProposalsMethod(sc);
		addParseToExpectedElementsMethod(sc);
		addRemoveDuplicateEntriesMethod(sc);
		addRemoveDuplicateEntriesFromBucketMethod(sc);
		addRemoveInvalidEntriesAtEndMethod(sc);
		addRemoveKeywordsEndingBeforeIndexMethod(sc);
		addFindPrefixMethod(sc);
		addDeriveProposalsMethod1(sc);
		addDeriveProposalsMethod2(sc);
		addHandleEnumAttributeMethod(sc);
		addHandleNCReferenceMethod(sc);
		addHandleAttributeMethod(sc);
		addHandleKeywordMethod(sc);
		addHandleBooleanTerminalMethod(sc);
		addHandleEnumerationTerminalMethod(sc);
		addHandleLiteralMethod(sc);
		addSetPrefixesMethod(sc);
		addGetExpectedElementsAtMethod(sc);
		addGetEndMethod(sc);
		addMatchesMethod(sc);
		addGetImageMethod(sc);
		addFindCorrectContainerMethod(sc);
		addFindHookParentMethod(sc);
	}

	private void addRemoveKeywordsEndingBeforeIndexMethod(JavaComposite sc) {
		sc.addJavadoc("Removes all proposals for keywords that end before the given index.");
		sc.add("protected void removeKeywordsEndingBeforeIndex(" + COLLECTION(sc) + "<" + completionProposalClassName + "> proposals, int index) {");
		sc.add(sc.declareArrayList("toRemove", completionProposalClassName));
		sc.add("for (" + completionProposalClassName + " proposal : proposals) {");
		sc.add(expectedTerminalClassName + " expectedTerminal = proposal.getExpectedTerminal();");
		sc.add(iExpectedElementClassName + " terminal = expectedTerminal.getTerminal();");
		sc.add("if (terminal instanceof " + expectedCsStringClassName + ") {");
		sc.add(expectedCsStringClassName + " csString = (" + expectedCsStringClassName + ") terminal;");
		sc.add("int startExcludingHiddenTokens = expectedTerminal.getStartExcludingHiddenTokens();");
		sc.add("if (startExcludingHiddenTokens + csString.getValue().length() - 1 < index) {");
		sc.add("toRemove.add(proposal);");
		sc.add("}");
		sc.add("}");
		sc.add("}");
		sc.add("proposals.removeAll(toRemove);");
		sc.add("}");
		sc.addLineBreak();
	}

	private void addGetImageMethod(JavaComposite sc) {
		// TODO attach images for keywords and attributes
		sc.add("protected " + IMAGE(sc) + " getImage(" + E_OBJECT(sc) + " element) {");
		sc.add("if (!" + PLATFORM(sc) + ".isRunning()) {");
		sc.add("return null;");
		sc.add("}");
		generatorUtil.addCreateAdapterFactoryCode(sc);
		sc.add(ADAPTER_FACTORY_LABEL_PROVIDER(sc) + " labelProvider = new " + ADAPTER_FACTORY_LABEL_PROVIDER(sc) + "(adapterFactory);");
		sc.add("return labelProvider.getImage(element);");
		sc.add("}");
		sc.addLineBreak();
	}

	private void addGetEndMethod(JavaComposite sc) {
		sc.addJavadoc(
			"Calculates the end index of the expected element at allExpectedElements[index]. " +
			"To determine the end, the subsequent expected elements from the array of all " +
			"expected elements are used. An element is considered to end one character " +
			"before the next elements starts."
		);
		sc.add("protected int getEnd(" + expectedTerminalClassName + "[] allExpectedElements, int indexInList) {");
		sc.add(expectedTerminalClassName + " elementAtIndex = allExpectedElements[indexInList];");
		sc.add("int startIncludingHidden = elementAtIndex.getStartIncludingHiddenTokens();");
		sc.add("int startExcludingHidden = elementAtIndex.getStartExcludingHiddenTokens();");
		sc.add("for (int i = indexInList + 1; i < allExpectedElements.length; i++) {");
		sc.add(expectedTerminalClassName + " elementAtI = allExpectedElements[i];");
		sc.add("int startIncludingHiddenForI = elementAtI.getStartIncludingHiddenTokens();");
		sc.add("int startExcludingHiddenForI = elementAtI.getStartExcludingHiddenTokens();");
		sc.add("if (startIncludingHidden != startIncludingHiddenForI || startExcludingHidden != startExcludingHiddenForI) {");
		sc.add("return startIncludingHiddenForI - 1;");
		sc.add("}");
		sc.add("}");
		sc.add("return Integer.MAX_VALUE;");
		sc.add("}");
		sc.addLineBreak();
	}

	private void addSetPrefixesMethod(JavaComposite sc) {
		sc.addJavadoc(
			"Calculates the prefix for each given expected element. " +
			"The prefix depends on the current document content, the cursor position, and " +
			"the position where the element is expected."
		);
		sc.add("protected void setPrefixes(" + LIST(sc) + "<" + expectedTerminalClassName + "> expectedElements, String content, int cursorOffset) {");
		sc.add("if (cursorOffset < 0) {");
		sc.add("return;");
		sc.add("}");
		sc.add("for (" + expectedTerminalClassName + " expectedElement : expectedElements) {");
		sc.add("String prefix = findPrefix(expectedElements, expectedElement, content, cursorOffset);");
		sc.add("expectedElement.setPrefix(prefix);");
		sc.add("}");
		sc.add("}");
		sc.addLineBreak();
	}

	private void addHandleKeywordMethod(JavaComposite sc) {
		sc.addJavadoc(
			"Creates a set of completion proposals from the given keyword."
		);
		sc.add("protected " + COLLECTION(sc) + "<" + completionProposalClassName + "> handleKeyword(" + expectedTerminalClassName + " expectedTerminal, " + expectedCsStringClassName + " csString, String prefix, " + E_OBJECT(sc) + " container) {");
		sc.add("String proposal = csString.getValue();");
		sc.add("boolean matchesPrefix = matches(proposal, prefix);");
		sc.add("return " + COLLECTIONS(sc) + ".singleton(new " + completionProposalClassName + "(expectedTerminal, proposal, prefix, matchesPrefix, null, container));");
		sc.add("}");
		sc.addLineBreak();
	}

	private void addHandleBooleanTerminalMethod(JavaComposite sc) {
		sc.addJavadoc(
			"Creates a set of (two) completion proposals from the given boolean terminal."
		);
		sc.add("protected " + COLLECTION(sc) + "<" + completionProposalClassName + "> handleBooleanTerminal(" + expectedTerminalClassName + " expectedTerminal, " + expectedBooleanTerminalClassName + " expectedBooleanTerminal, String prefix) {");
		sc.add(COLLECTION(sc) + "<" + completionProposalClassName + "> result = new " + LINKED_HASH_SET(sc) + "<" + completionProposalClassName + ">(2);");
		sc.add(booleanTerminalClassName + " booleanTerminal = expectedBooleanTerminal.getBooleanTerminal();");
		sc.add("result.addAll(handleLiteral(expectedTerminal, booleanTerminal.getAttribute(), prefix, booleanTerminal.getTrueLiteral()));");
		sc.add("result.addAll(handleLiteral(expectedTerminal, booleanTerminal.getAttribute(), prefix, booleanTerminal.getFalseLiteral()));");
		sc.add("return result;");
		sc.add("}");
		sc.addLineBreak();
	}

	private void addHandleLiteralMethod(JavaComposite sc) {
		sc.add("protected " + COLLECTION(sc) + "<" + completionProposalClassName + "> handleLiteral(" + expectedTerminalClassName + " expectedTerminal, " + E_ATTRIBUTE(sc) + " attribute, String prefix, String literal) {");
		sc.add("if (\"\".equals(literal)) {");
		sc.add("return " + COLLECTIONS(sc) + ".emptySet();");
		sc.add("}");
		sc.add("boolean matchesPrefix = matches(literal, prefix);");
		sc.add("return " + COLLECTIONS(sc) + ".singleton(new " + completionProposalClassName + "(expectedTerminal, literal, prefix, matchesPrefix, null, null));");
		sc.add("}");
		sc.addLineBreak();
	}

	private void addHandleEnumerationTerminalMethod(JavaComposite sc) {
		sc.addJavadoc(
			"Creates a set of completion proposals from the given enumeration terminal. " +
			"For each enumeration literal one proposal is created."
		);
		sc.add("protected " + COLLECTION(sc) + "<" + completionProposalClassName + "> handleEnumerationTerminal(" + expectedTerminalClassName + " expectedTerminal, " + expectedEnumerationTerminalClassName + " expectedEnumerationTerminal, String prefix) {");
		sc.add(COLLECTION(sc) + "<" + completionProposalClassName + "> result = new " + LINKED_HASH_SET(sc) + "<" + completionProposalClassName + ">(2);");
		sc.add(enumerationTerminalClassName + " enumerationTerminal = expectedEnumerationTerminal.getEnumerationTerminal();");
		sc.add(MAP(sc) + "<String, String> literalMapping = enumerationTerminal.getLiteralMapping();");
		sc.add("for (String literalName : literalMapping.keySet()) {");
		sc.add("result.addAll(handleLiteral(expectedTerminal, enumerationTerminal.getAttribute(), prefix, literalMapping.get(literalName)));");
		sc.add("}");
		sc.add("return result;");
		sc.add("}");
		sc.addLineBreak();
	}

	private void addMatchesMethod(JavaComposite sc) {
		sc.addJavadoc(
			"Checks whether the given proposed string matches the prefix. " +
			"The two strings are compared ignoring the case. The prefix is " +
			"also considered to match if is a camel case representation of " +
			"the proposal."
		);
		sc.add("protected boolean matches(String proposal, String prefix) {");
		sc.add("if (proposal == null || prefix == null) {");
		sc.add("return false;");
		sc.add("}");
		sc.add("return (proposal.toLowerCase().startsWith(prefix.toLowerCase()) || " + stringUtilClassName + ".matchCamelCase(prefix, proposal) != null) && !proposal.equals(prefix);");
		sc.add("}");
		sc.addLineBreak();
	}

	private void addHandleEnumAttributeMethod(JavaComposite sc) {
		sc.add("protected " + COLLECTION(sc) + "<" + completionProposalClassName + "> handleEnumAttribute(" + expectedTerminalClassName + " expectedTerminal, " + expectedStructuralFeatureClassName + " expectedFeature, " + E_ENUM(sc) + " enumType, String prefix, " + E_OBJECT(sc) + " container) {");
		sc.add(COLLECTION(sc) + "<" + E_ENUM_LITERAL(sc) + "> enumLiterals = enumType.getELiterals();");
		sc.add(COLLECTION(sc) + "<" + completionProposalClassName + "> result = new " + LINKED_HASH_SET(sc) + "<" + completionProposalClassName + ">();");
		sc.add("for (" + E_ENUM_LITERAL(sc) + " literal : enumLiterals) {");
		sc.add("String unResolvedLiteral = literal.getLiteral();");
		sc.addComment("use token resolver to get de-resolved value of the literal");
		sc.add(iTokenResolverFactoryClassName + " tokenResolverFactory = metaInformation.getTokenResolverFactory();");
		sc.add(iTokenResolverClassName + " tokenResolver = tokenResolverFactory.createTokenResolver(expectedFeature.getTokenName());");
		sc.add("String resolvedLiteral = tokenResolver.deResolve(unResolvedLiteral, expectedFeature.getFeature(), container);");
		sc.add("boolean matchesPrefix = matches(resolvedLiteral, prefix);");
		sc.add("result.add(new " + completionProposalClassName + "(expectedTerminal, resolvedLiteral, prefix, matchesPrefix, expectedFeature.getFeature(), container));");
		sc.add("}");
		sc.add("return result;");
		sc.add("}");
		sc.addLineBreak();
	}

	private void addHandleAttributeMethod(JavaComposite sc) {
		sc.add("protected " + COLLECTION(sc) + "<" + completionProposalClassName + "> handleAttribute(" + expectedTerminalClassName + " expectedTerminal, " + expectedStructuralFeatureClassName + " expectedFeature, " + E_OBJECT(sc) + " container, " + E_ATTRIBUTE(sc) + " attribute, String prefix) {");
		sc.add(COLLECTION(sc) + "<" + completionProposalClassName + "> resultSet = new " + LINKED_HASH_SET(sc) + "<" + completionProposalClassName + ">();");
		sc.add("Object[] defaultValues = attributeValueProvider.getDefaultValues(attribute);");
		sc.add("if (defaultValues != null) {");
		sc.add("for (Object defaultValue : defaultValues) {");
		sc.add("if (defaultValue != null) {");
		sc.add(iTokenResolverFactoryClassName + " tokenResolverFactory = metaInformation.getTokenResolverFactory();");
		sc.add("String tokenName = expectedFeature.getTokenName();");
		sc.add("if (tokenName != null) {");
		sc.add(iTokenResolverClassName + " tokenResolver = tokenResolverFactory.createTokenResolver(tokenName);");
		sc.add("if (tokenResolver != null) {");
		sc.add("String defaultValueAsString = tokenResolver.deResolve(defaultValue, attribute, container);");
		sc.add("boolean matchesPrefix = matches(defaultValueAsString, prefix);");
		sc.add("resultSet.add(new " + completionProposalClassName + "(expectedTerminal, defaultValueAsString, prefix, matchesPrefix, expectedFeature.getFeature(), container));");
		sc.add("}");
		sc.add("}");
		sc.add("}");
		sc.add("}");
		sc.add("}");
		sc.add("return resultSet;");
		sc.add("}");
		sc.addLineBreak();
	}

	private void addHandleNCReferenceMethod(JavaComposite sc) {
		sc.add("protected " + COLLECTION(sc) + "<" + completionProposalClassName + "> handleNCReference(" + expectedTerminalClassName + " expectedTerminal, " + E_OBJECT(sc) + " container, " + E_REFERENCE(sc) + " reference, String prefix, String tokenName) {");
		sc.addComment(
			"proposals for non-containment references are derived by calling the " + 
			"reference resolver switch in fuzzy mode."
		);
		sc.add(iReferenceResolverSwitchClassName + " resolverSwitch = metaInformation.getReferenceResolverSwitch();");
		sc.add(iTokenResolverFactoryClassName + " tokenResolverFactory = metaInformation.getTokenResolverFactory();");
		sc.add(iReferenceResolveResultClassName + "<" + E_OBJECT(sc) + "> result = new " + referenceResolveResultClassName + "<" + E_OBJECT(sc) + ">(true);");
		sc.add("resolverSwitch.resolveFuzzy(prefix, container, reference, 0, result);");
		sc.add(COLLECTION(sc) + "<" + iReferenceMappingClassName + "<" + E_OBJECT(sc) + ">> mappings = result.getMappings();");
		sc.add("if (mappings != null) {");
		sc.add(COLLECTION(sc) + "<" + completionProposalClassName + "> resultSet = new " + LINKED_HASH_SET(sc) + "<" + completionProposalClassName + ">();");
		sc.add("for (" + iReferenceMappingClassName + "<" + E_OBJECT(sc) + "> mapping : mappings) {");
		sc.add(IMAGE(sc) + " image = null;");
		sc.add("if (mapping instanceof " + elementMappingClassName + "<?>) {");
		sc.add(elementMappingClassName + "<?> elementMapping = (" + elementMappingClassName + "<?>) mapping;");
		sc.add("Object target = elementMapping.getTargetElement();");
		sc.addComment("de-resolve reference to obtain correct identifier");
		sc.add(iTokenResolverClassName + " tokenResolver = tokenResolverFactory.createTokenResolver(tokenName);");
		sc.add("final String identifier = tokenResolver.deResolve(elementMapping.getIdentifier(), reference, container);");
		sc.add("if (target instanceof " + E_OBJECT(sc) + ") {");
		sc.add("image = getImage((" + E_OBJECT(sc) + ") target);");
		sc.add("}");
		sc.add("boolean matchesPrefix = matches(identifier, prefix);");
		sc.add(completionProposalClassName + " proposal = new " + completionProposalClassName + "(expectedTerminal, identifier, prefix, matchesPrefix, reference, container, image);");
		sc.add("proposal.setReferenceTarget(target);");
		sc.add("resultSet.add(proposal);");
		sc.add("}");
		sc.add("}");
		sc.add("return resultSet;");
		sc.add("}");
		sc.add("return " + COLLECTIONS(sc) + ".emptyList();");
		sc.add("}");
		sc.addLineBreak();
	}

	private void addFindCorrectContainerMethod(JavaComposite sc) {
		sc.add("protected " + E_OBJECT(sc) + " findCorrectContainer(" + expectedTerminalClassName + " expectedTerminal) {");
		sc.add(E_OBJECT(sc) + " container = expectedTerminal.getContainer();");
		sc.add(E_CLASS(sc) + " ruleMetaclass = expectedTerminal.getTerminal().getRuleMetaclass();");
		sc.add("if (ruleMetaclass.isInstance(container)) {");
		sc.addComment("container is correct for expected terminal");
		sc.add("return container;");
		sc.add("}");
		sc.addComment("the container is wrong");
		sc.add(E_OBJECT(sc) + " parent = null;");
		sc.add(E_OBJECT(sc) + " previousParent = null;");
		sc.add(E_OBJECT(sc) + " correctContainer = null;");
		sc.add(E_OBJECT(sc) + " hookableParent = null;");
		sc.add(containmentTraceClassName + " containmentTrace = expectedTerminal.getContainmentTrace();");
		sc.add(E_CLASS(sc) + " startClass = containmentTrace.getStartClass();");
		sc.add(containedFeatureClassName + " currentLink = null;");
		sc.add(containedFeatureClassName + " previousLink = null;");
		sc.add(containedFeatureClassName + "[] containedFeatures = containmentTrace.getPath();");
		sc.add("for (int i = 0; i < containedFeatures.length; i++) {");
		sc.add("currentLink = containedFeatures[i];");
		sc.add("if (i > 0) {");
		sc.add("previousLink = containedFeatures[i - 1];");
		sc.add("}");
		sc.add(E_CLASS(sc) + " containerClass = currentLink.getContainerClass();");
		sc.add("hookableParent = findHookParent(container, startClass, currentLink, parent);");
		sc.add("if (hookableParent != null) {");
		sc.addComment("we found the correct parent");
		sc.add("break;");
		sc.add("} else {");
		sc.add("previousParent = parent;");
		sc.add("parent = containerClass.getEPackage().getEFactoryInstance().create(containerClass);");
		sc.add("if (parent != null) {");
		sc.add("if (previousParent == null) {");
		sc.addComment("replace container for expectedTerminal with correctContainer");
		sc.add("correctContainer = parent;");
		sc.add("} else {");
		sc.addComment(
			"This assignment is only performed to get rid of a warning about a potential null pointer access. " +
			"Variable 'previousLink' cannot be null here, because it is initialized for all loop iterations where " +
			"'i' is greather than 0 and for the case where 'i' equals zero, this path is never executed, because " +
			"'previousParent' is null in this case."
		);
		sc.add(containedFeatureClassName + " link = previousLink;");
		sc.add(eObjectUtilClassName + ".setFeature(parent, link.getFeature(), previousParent, false);");
		sc.add("}");
		sc.add("}");
		sc.add("}");
		sc.add("}");
		/*
		sc.add("if (previousParent != null) {");
		sc.add(eObjectUtilClassName + ".setFeature(parent, previousLink.getFeature(), previousParent, false);");
		sc.add("}");
		*/
		sc.addLineBreak();
		sc.add("if (correctContainer == null) {");
		sc.add("correctContainer = container;");
		sc.add("}");
		sc.addLineBreak();
		sc.add("if (currentLink == null) {");
		sc.add("return correctContainer;");
		sc.add("}");
		sc.addLineBreak();
		sc.add("hookableParent = findHookParent(container, startClass, currentLink, parent);");
		sc.addLineBreak();

		sc.add("final " + E_OBJECT(sc) + " finalHookableParent = hookableParent;");
		sc.add("final " + E_STRUCTURAL_FEATURE(sc) + " finalFeature = currentLink.getFeature();");
		sc.add("final " + E_OBJECT(sc) + " finalParent = parent;");
		sc.add("if (parent != null && hookableParent != null) {");
		sc.add("expectedTerminal.setAttachmentCode(new Runnable() {");
		sc.addLineBreak();
		sc.add("public void run() {");
		sc.add(eObjectUtilClassName + ".setFeature(finalHookableParent, finalFeature, finalParent, false);");
		sc.add("}");
		sc.add("});");
		sc.add("}");
		sc.add("return correctContainer;");
		sc.add("}");
		sc.addLineBreak();
	}
	
	private void addFindHookParentMethod(JavaComposite sc) {
		sc.addJavadoc(
			"Walks up the containment hierarchy to find an EObject that is able " +
			"to hold (contain) the given object.");
		sc.add("protected " + E_OBJECT(sc) + " findHookParent(" + E_OBJECT(sc) + " container, " + E_CLASS(sc) + " startClass, " + containedFeatureClassName + " currentLink, " + E_OBJECT(sc) + " object) {");
		sc.add(E_CLASS(sc) + " containerClass = currentLink.getContainerClass();");
		sc.add("while (container != null) {");
		sc.add("if (containerClass.isInstance(object)) {");
		sc.add("if (startClass.equals(container.eClass())) {");
		sc.add("return container;");
		sc.add("}");
		sc.add("}");
		sc.add("container = container.eContainer();");
		sc.add("}");
		sc.add("return null;");
		sc.add("}");
		sc.addLineBreak();
	}
	
	private void addDeriveProposalsMethod2(JavaComposite sc) {
		// TODO mseifert: remove parameter 'resource'?
		// TODO mseifert: all methods that are called by this method and that
		// take a parameter 'expectedTerminal' do not need the parameter 'prefix'
		sc.add("protected " + COLLECTION(sc) + "<" + completionProposalClassName + "> deriveProposals(final " + expectedTerminalClassName + " expectedTerminal, String content, " + iTextResourceClassName + " resource, int cursorOffset) {");
		sc.add(iExpectedElementClassName + " expectedElement = (" + iExpectedElementClassName + ") expectedTerminal.getTerminal();");
		sc.add("if (expectedElement instanceof " + expectedCsStringClassName + ") {");
		sc.add(expectedCsStringClassName + " csString = (" + expectedCsStringClassName + ") expectedElement;");
		sc.add("return handleKeyword(expectedTerminal, csString, expectedTerminal.getPrefix(), expectedTerminal.getContainer());");
		sc.add("} else if (expectedElement instanceof " + expectedBooleanTerminalClassName + ") {");
		sc.add(expectedBooleanTerminalClassName + " expectedBooleanTerminal = (" + expectedBooleanTerminalClassName + ") expectedElement;");
		sc.add("return handleBooleanTerminal(expectedTerminal, expectedBooleanTerminal, expectedTerminal.getPrefix());");
		sc.add("} else if (expectedElement instanceof " + expectedEnumerationTerminalClassName + ") {");
		sc.add(expectedEnumerationTerminalClassName + " expectedEnumerationTerminal = (" + expectedEnumerationTerminalClassName + ") expectedElement;");
		sc.add("return handleEnumerationTerminal(expectedTerminal, expectedEnumerationTerminal, expectedTerminal.getPrefix());");
		sc.add("} else if (expectedElement instanceof " + expectedStructuralFeatureClassName + ") {");
		sc.add("final " + expectedStructuralFeatureClassName + " expectedFeature = (" + expectedStructuralFeatureClassName + ") expectedElement;");
		sc.add("final " + E_STRUCTURAL_FEATURE(sc) + " feature = expectedFeature.getFeature();");
		sc.add("final " + E_CLASSIFIER(sc) + " featureType = feature.getEType();");
		sc.add("final " + E_OBJECT(sc) + " container = findCorrectContainer(expectedTerminal);");
		sc.addLineBreak();
		sc.addComment(
			"Here it gets really crazy. We need to modify the model in a way that reflects the " +
			"state the model would be in, if the expected terminal were present. After computing the " +
			"corresponding completion proposals, the original state of the model is restored. " +
			"This procedure is required, because different models can be required for different " +
			"completion situations. This can be particularly observed when the user has not yet " +
			"typed a character that starts an element to be completed."
		);
		sc.add("final " + COLLECTION(sc) + "<" + completionProposalClassName + "> proposals = new " + ARRAY_LIST(sc) + "<" + completionProposalClassName + ">();");
		sc.add("expectedTerminal.materialize(new Runnable() {");
		sc.addLineBreak();
		sc.add("public void run() {");
		sc.add("if (feature instanceof " + E_REFERENCE(sc) + ") {");
		sc.add(E_REFERENCE(sc) + " reference = (" + E_REFERENCE(sc) + ") feature;");
		sc.add("if (featureType instanceof " + E_CLASS(sc) + ") {");
		sc.add("if (reference.isContainment()) {");
		sc.addComment("the FOLLOW set should contain only non-containment references");
		sc.add("assert false;");
		sc.add("} else {");
		sc.add("proposals.addAll(handleNCReference(expectedTerminal, container, reference, expectedTerminal.getPrefix(), expectedFeature.getTokenName()));");
		sc.add("}");
		sc.add("}");
		sc.add("} else if (feature instanceof " + E_ATTRIBUTE(sc) + ") {");
		sc.add(E_ATTRIBUTE(sc) + " attribute = (" + E_ATTRIBUTE(sc) + ") feature;");
		sc.add("if (featureType instanceof " + E_ENUM(sc) + ") {");
		sc.add(E_ENUM(sc) + " enumType = (" + E_ENUM(sc) + ") featureType;");
		sc.add("proposals.addAll(handleEnumAttribute(expectedTerminal, expectedFeature, enumType, expectedTerminal.getPrefix(), container));");
		sc.add("} else {");
		sc.addComment(
			"handle EAttributes (derive default value depending on " +
			"the type of the attribute, figure out token resolver, and " + 
			"call deResolve())"
		);
		sc.add("proposals.addAll(handleAttribute(expectedTerminal, expectedFeature, container, attribute, expectedTerminal.getPrefix()));");
		sc.add("}");
		sc.add("} else {");
		sc.addComment("there should be no other subclass of EStructuralFeature");
		sc.add("assert false;");
		sc.add("}");
		sc.add("}");
		sc.add("});");
		sc.addComment("Return the proposals that were computed in the closure call.");
		sc.add("return proposals;");
		sc.add("} else {");
		sc.addComment("there should be no other class implementing IExpectedElement");
		sc.add("assert false;");
		sc.add("}");
		sc.add("return " + COLLECTIONS(sc) + ".emptyList();");
		sc.add("}");
		sc.addLineBreak();
	}

	private void addDeriveProposalsMethod1(JavaComposite sc) {
		sc.add("protected " + COLLECTION(sc) + "<" + completionProposalClassName + "> deriveProposals(" + LIST(sc) + "<" + expectedTerminalClassName + "> expectedElements, String content, " + iTextResourceClassName + " resource, int cursorOffset) {");
		sc.add(COLLECTION(sc) + "<" + completionProposalClassName + "> resultSet = new " + LINKED_HASH_SET(sc) + "<" + completionProposalClassName + ">();");
		sc.add("for (" + expectedTerminalClassName + " expectedElement : expectedElements) {");
		sc.add("resultSet.addAll(deriveProposals(expectedElement, content, resource, cursorOffset));");
		sc.add("}");
		sc.add("return resultSet;");
		sc.add("}");
		sc.addLineBreak();
	}

	private void addFindPrefixMethod(JavaComposite sc) {
		sc.add("protected String findPrefix(" + LIST(sc) + "<" + expectedTerminalClassName + "> expectedElements, " + expectedTerminalClassName + " expectedAtCursor, String content, int cursorOffset) {");
		sc.add("if (cursorOffset < 0) {");
		sc.add("return \"\";");
		sc.add("}");

		sc.addLineBreak();
		sc.add("int end = 0;");
		sc.add("for (" + expectedTerminalClassName + " expectedElement : expectedElements) {");
		sc.add("if (expectedElement == expectedAtCursor) {");
		sc.add("final int start = expectedElement.getStartExcludingHiddenTokens();");
		sc.add("if (start >= 0  && start < Integer.MAX_VALUE) {");
		sc.add("end = start;");
		sc.add("}");
		sc.add("break;");
		sc.add("}");
		sc.add("}");
		sc.add("end = Math.min(end, cursorOffset);");
		sc.add("final String prefix = content.substring(end, Math.min(content.length(), cursorOffset));");
		if (INSERT_DEBUG_OUTPUT_CODE) {
			sc.add("System.out.println(\"Found prefix '\" + prefix + \"'\");");
		}
		sc.add("return prefix;");
		sc.add("}");
		sc.addLineBreak();
	}

	private void addRemoveInvalidEntriesAtEndMethod(JavaComposite sc) {
		sc.add("protected void removeInvalidEntriesAtEnd(" + LIST(sc) + "<" + expectedTerminalClassName + "> expectedElements) {");
		sc.add("for (int i = 0; i < expectedElements.size() - 1;) {");
		sc.add(expectedTerminalClassName + " elementAtIndex = expectedElements.get(i);");
		sc.add(expectedTerminalClassName + " elementAtNext = expectedElements.get(i + 1);");
		sc.addLineBreak();
		sc.addComment(
				"If the two expected elements have a different parent in the syntax definition, " +
				"we must not discard the second element, because it probably stems from a parent rule."
		);
		sc.add(syntaxElementClassName + " symtaxElementOfThis = elementAtIndex.getTerminal().getSymtaxElement();");
		sc.add(syntaxElementClassName + " symtaxElementOfNext = elementAtNext.getTerminal().getSymtaxElement();");
		sc.add("boolean differentParent = symtaxElementOfNext.getParent() != symtaxElementOfThis.getParent();");
		sc.addLineBreak();
		sc.add("boolean sameStartExcludingHiddenTokens = elementAtIndex.getStartExcludingHiddenTokens() == elementAtNext.getStartExcludingHiddenTokens();");
		sc.add("boolean differentFollowSet = elementAtIndex.getFollowSetID() != elementAtNext.getFollowSetID();");
		sc.add("if (sameStartExcludingHiddenTokens && differentFollowSet && !differentParent) {");
		sc.add("expectedElements.remove(i + 1);");
		sc.add("} else {");
		sc.add("i++;");
		sc.add("}");
		sc.add("}");
		sc.add("}");
		sc.addLineBreak();
	}

	private void addRemoveDuplicateEntriesFromBucketMethod(JavaComposite sc) {
		sc.addJavadoc(
			"Removes all expected elements that refer to the same terminal. " +
			"Attention: This method assumes that the given list of expected " +
			"terminals contains only elements that start at the same position."
		);
		sc.add("protected void removeDuplicateEntriesFromBucket(" + LIST(sc) + "<" + expectedTerminalClassName + "> expectedElements) {");
		sc.add("int size = expectedElements.size();");
		sc.add("for (int i = 0; i < size - 1; i++) {");
		sc.add(expectedTerminalClassName + " elementAtIndex = expectedElements.get(i);");
		sc.add(iExpectedElementClassName + " terminal = elementAtIndex.getTerminal();");
		sc.add("for (int j = i + 1; j < size;) {");
		sc.add(expectedTerminalClassName + " elementAtNext = expectedElements.get(j);");
		sc.add("if (terminal.equals(elementAtNext.getTerminal())) {");
		sc.add("expectedElements.remove(j);");
		sc.add("size--;");
		sc.add("} else {");
		sc.add("j++;");
		sc.add("}");
		sc.add("}");
		sc.add("}");
		sc.add("}");
		sc.addLineBreak();
	}
		
	private void addRemoveDuplicateEntriesMethod(JavaComposite sc) {
		sc.addJavadoc(
			"Removes all expected elements that refer to the same terminal and " +
			"that start at the same position."
		);
		sc.add("protected void removeDuplicateEntries(" + LIST(sc) + "<" + expectedTerminalClassName + "> expectedElements) {");
		sc.add("int size = expectedElements.size();");
		sc.addComment(
			"We split the list of expected elements into buckets where each bucket " +
			"contains the elements that start at the same position."
		);
		sc.add(MAP(sc) + "<Integer, " + LIST(sc) + "<" + expectedTerminalClassName + ">> map = new " + LINKED_HASH_MAP(sc) + "<Integer, " + LIST(sc) + "<" + expectedTerminalClassName + ">>();");
		sc.add("for (int i = 0; i < size; i++) {");
		sc.add(expectedTerminalClassName + " elementAtIndex = expectedElements.get(i);");
		sc.add("int start1 = elementAtIndex.getStartExcludingHiddenTokens();");
		sc.add(LIST(sc) + "<" + expectedTerminalClassName + "> list = map.get(start1);");
		sc.add("if (list == null) {");
		sc.add("list = new " + ARRAY_LIST(sc) + "<" + expectedTerminalClassName + ">();");
		sc.add("map.put(start1, list);");
		sc.add("}");
		sc.add("list.add(elementAtIndex);");
		sc.add("}");
		sc.addLineBreak();

		sc.addComment(
			"Then, we remove all duplicate elements from each bucket individually."
		);
		sc.add("for (int position : map.keySet()) {");
		sc.add(LIST(sc) + "<" + expectedTerminalClassName + "> list = map.get(position);");
		sc.add("removeDuplicateEntriesFromBucket(list);");
		sc.add("}");
		sc.addLineBreak();

		sc.addComment("After removing all duplicates, we merge the buckets.");
		sc.add("expectedElements.clear();");
		sc.add("for (int position : map.keySet()) {");
		sc.add(LIST(sc) + "<" + expectedTerminalClassName + "> list = map.get(position);");
		sc.add("expectedElements.addAll(list);");
		sc.add("}");

		sc.add("}");
		sc.addLineBreak();
	}

	private void addComputeCompletionProposalsMethod(JavaComposite sc) {
		sc.addJavadoc(
			"Computes a set of proposals for the given document assuming the cursor is " +
			"at 'cursorOffset'. The proposals are derived using the meta information, i.e., " +
			"the generated language plug-in.",
			"@param originalResource the resource to compute completions for",
			"@param content the documents content",
			"@param cursorOffset the current offset of the cursor",
			"@return an array of completion proposals"
		);
		
		sc.add("public " + completionProposalClassName + "[] computeCompletionProposals(" + iTextResourceClassName + " originalResource, String content, int cursorOffset) {");
		sc.add(RESOURCE_SET(sc) + " resourceSet = new " + RESOURCE_SET_IMPL(sc) + "();");
		sc.addComment("the shadow resource needs the same URI because reference resolvers may use the URI to resolve external references");
		sc.add(iTextResourceClassName + " resource = (" + iTextResourceClassName + ") resourceSet.createResource(originalResource.getURI());");
		sc.add(BYTE_ARRAY_INPUT_STREAM(sc) + " inputStream = new " + BYTE_ARRAY_INPUT_STREAM(sc) + "(content.getBytes());");
		sc.add(iMetaInformationClassName + " metaInformation = resource.getMetaInformation();");
		sc.add(iTextParserClassName + " parser = metaInformation.createParser(inputStream, null);");
		sc.add(expectedTerminalClassName + "[] expectedElements = parseToExpectedElements(parser, resource, cursorOffset);");
		sc.add("if (expectedElements == null) {");
		sc.add("return new " + completionProposalClassName + "[0];");
		sc.add("}");
		sc.add("if (expectedElements.length == 0) {");
		sc.add("return new " + completionProposalClassName + "[0];");
		sc.add("}");

		sc.add(LIST(sc) + "<" + expectedTerminalClassName + "> expectedAfterCursor = " + ARRAYS(sc) + ".asList(getElementsExpectedAt(expectedElements, cursorOffset));");
		sc.add(LIST(sc) + "<" + expectedTerminalClassName + "> expectedBeforeCursor = " + ARRAYS(sc) + ".asList(getElementsExpectedAt(expectedElements, cursorOffset - 1));");
		if (INSERT_DEBUG_OUTPUT_CODE) {
			sc.add("System.out.println(\"parseToCursor(\" + cursorOffset + \") BEFORE CURSOR \" + expectedBeforeCursor);");
			sc.add("System.out.println(\"parseToCursor(\" + cursorOffset + \") AFTER CURSOR  \" + expectedAfterCursor);");
		}
		
		sc.add("setPrefixes(expectedAfterCursor, content, cursorOffset);");
		sc.add("setPrefixes(expectedBeforeCursor, content, cursorOffset);");

		sc.addLineBreak();
		sc.addComment("First, we derive all possible proposals from the set of elements that are expected at the cursor position.");
		sc.add(COLLECTION(sc) + "<" + completionProposalClassName + "> allProposals = new " + LINKED_HASH_SET(sc) + "<" + completionProposalClassName + ">();");
		sc.add(COLLECTION(sc) + "<" + completionProposalClassName + "> rightProposals = deriveProposals(expectedAfterCursor, content, resource, cursorOffset);");
		sc.add(COLLECTION(sc) + "<" + completionProposalClassName + "> leftProposals = deriveProposals(expectedBeforeCursor, content, resource, cursorOffset - 1);");
		sc.add("removeKeywordsEndingBeforeIndex(leftProposals, cursorOffset);");

		sc.addLineBreak();
		sc.addComment(
			"Second, the set of left proposals (i.e., the ones before the cursor) is " +
			"checked for emptiness. If the set is empty, the right proposals (i.e., " +
			"the ones after the cursor) are also considered. If the set is not empty, " + 
			"the right proposal are discarded, because it does not make sense to " +
			"propose them until the element before the cursor was completed."
		);
		sc.add("allProposals.addAll(leftProposals);");
		sc.addComment("Count the proposals before the cursor that match the prefix");
		sc.add("int leftMatchingProposals = 0;");
		sc.add("for (" + completionProposalClassName + " leftProposal : leftProposals) {");
		sc.add("if (leftProposal.isMatchesPrefix()) {");
		sc.add("leftMatchingProposals++;");
		sc.add("}");
		sc.add("}");
		sc.add("if (leftMatchingProposals == 0) {");
		sc.add("allProposals.addAll(rightProposals);");
		sc.add("}");
		
		sc.addLineBreak();
		sc.addComment(
			"Third, the proposals are sorted according to their relevance. " +
			"Proposals that matched the prefix are preferred over ones that did not. " +
			"Finally, proposals are sorted alphabetically."
		);
		sc.add("final " + LIST(sc) + "<" + completionProposalClassName + "> sortedProposals = new " + ARRAY_LIST(sc) + "<" + completionProposalClassName + ">(allProposals);");
		sc.add(COLLECTIONS(sc) + ".sort(sortedProposals);");

		sc.add(E_OBJECT(sc) + " root = null;");
		sc.add("if (!resource.getContents().isEmpty()) {");
		sc.add("root = resource.getContents().get(0);");
		sc.add("}");
		sc.add("for (" + completionProposalClassName + " proposal : sortedProposals) {");
		sc.add("proposal.setRoot(root);");
		sc.add("}");

		sc.addLineBreak();
		sc.add("return sortedProposals.toArray(new " + completionProposalClassName + "[sortedProposals.size()]);");
		sc.add("}");
		sc.addLineBreak();
	}

	private void addParseToExpectedElementsMethod(JavaComposite sc) {
		sc.add("public " + expectedTerminalClassName + "[] parseToExpectedElements(" + iTextParserClassName + " parser, " + iTextResourceClassName + " resource, int cursorOffset) {");
		sc.add("final " + LIST(sc) + "<" + expectedTerminalClassName + "> expectedElements = parser.parseToExpectedElements(null, resource, cursorOffset);");
		sc.add("if (expectedElements == null) {");
		sc.add("return new " + expectedTerminalClassName + "[0];");
		sc.add("}");
		sc.add("removeDuplicateEntries(expectedElements);");
		sc.add("removeInvalidEntriesAtEnd(expectedElements);");
		sc.add("return expectedElements.toArray(new " + expectedTerminalClassName + "[expectedElements.size()]);");
		sc.add("}");
		sc.addLineBreak();
	}

	private void addGetExpectedElementsAtMethod(JavaComposite sc) {
		sc.add("public " + expectedTerminalClassName + "[] getElementsExpectedAt(" + expectedTerminalClassName + "[] allExpectedElements, int cursorOffset) {");
		sc.add(LIST(sc) + "<" + expectedTerminalClassName + "> expectedAtCursor = new " + ARRAY_LIST(sc) + "<" + expectedTerminalClassName + ">();");
		sc.add("for (int i = 0; i < allExpectedElements.length; i++) {");
		sc.add(expectedTerminalClassName + " expectedElement = allExpectedElements[i];");
		sc.add("int startIncludingHidden = expectedElement.getStartIncludingHiddenTokens();");
		sc.add("int end = getEnd(allExpectedElements, i);");
		sc.add("if (cursorOffset >= startIncludingHidden && cursorOffset <= end) {");
		sc.add("expectedAtCursor.add(expectedElement);");
		sc.add("}");
		sc.add("}");
		sc.add("return expectedAtCursor.toArray(new " + expectedTerminalClassName + "[expectedAtCursor.size()]);");
		sc.add("}");
		sc.addLineBreak();
	}
}
