/*******************************************************************************
 * Copyright (c) 2006-2010 
 * Software Technology Group, Dresden University of Technology
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0 
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 * 
 * Contributors:
 *   Software Technology Group - TU Dresden, Germany 
 *      - initial API and implementation
 ******************************************************************************/
package org.emftext.sdk.codegen.resource.ui.generators.ui;

import static org.emftext.sdk.codegen.resource.generators.IClassNameConstants.ARRAYS;
import static org.emftext.sdk.codegen.resource.generators.IClassNameConstants.ARRAY_LIST;
import static org.emftext.sdk.codegen.resource.generators.IClassNameConstants.BYTE_ARRAY_INPUT_STREAM;
import static org.emftext.sdk.codegen.resource.generators.IClassNameConstants.COLLECTION;
import static org.emftext.sdk.codegen.resource.generators.IClassNameConstants.COLLECTIONS;
import static org.emftext.sdk.codegen.resource.generators.IClassNameConstants.E_ATTRIBUTE;
import static org.emftext.sdk.codegen.resource.generators.IClassNameConstants.E_CLASS;
import static org.emftext.sdk.codegen.resource.generators.IClassNameConstants.E_CLASSIFIER;
import static org.emftext.sdk.codegen.resource.generators.IClassNameConstants.E_ENUM;
import static org.emftext.sdk.codegen.resource.generators.IClassNameConstants.E_ENUM_LITERAL;
import static org.emftext.sdk.codegen.resource.generators.IClassNameConstants.E_OBJECT;
import static org.emftext.sdk.codegen.resource.generators.IClassNameConstants.E_REFERENCE;
import static org.emftext.sdk.codegen.resource.generators.IClassNameConstants.E_STRUCTURAL_FEATURE;
import static org.emftext.sdk.codegen.resource.generators.IClassNameConstants.ITERATOR;
import static org.emftext.sdk.codegen.resource.generators.IClassNameConstants.LINKED_HASH_SET;
import static org.emftext.sdk.codegen.resource.generators.IClassNameConstants.LIST;
import static org.emftext.sdk.codegen.resource.generators.IClassNameConstants.OBJECT;
import static org.emftext.sdk.codegen.resource.generators.IClassNameConstants.PLATFORM;
import static org.emftext.sdk.codegen.resource.generators.IClassNameConstants.RESOURCE_SET;
import static org.emftext.sdk.codegen.resource.generators.IClassNameConstants.RESOURCE_SET_IMPL;
import static org.emftext.sdk.codegen.resource.generators.IClassNameConstants.STRING;
import static org.emftext.sdk.codegen.resource.ui.IUIClassNameConstants.ADAPTER_FACTORY_LABEL_PROVIDER;
import static org.emftext.sdk.codegen.resource.ui.IUIClassNameConstants.IMAGE;

import org.emftext.sdk.codegen.composites.JavaComposite;
import org.emftext.sdk.codegen.composites.StringComposite;
import org.emftext.sdk.codegen.parameters.ArtifactParameter;
import org.emftext.sdk.codegen.resource.GenerationContext;
import org.emftext.sdk.codegen.resource.ui.UIGeneratorUtil;
import org.emftext.sdk.codegen.resource.ui.generators.UIJavaBaseGenerator;

public class CodeCompletionHelperGenerator extends UIJavaBaseGenerator<ArtifactParameter<GenerationContext>> {

	/**
	 * This is a temporary flag which can be used to enable the
	 * generation of debug output. This flag must be removed once
	 * all code completion issues have been resolved.
	 */
	public static final boolean INSERT_DEBUG_OUTPUT_CODE = false;

	private final UIGeneratorUtil generatorUtil = new UIGeneratorUtil();

	@Override
	public void generateJavaContents(JavaComposite sc) {
		
		sc.add("package " + getResourcePackageName() + ";");
		sc.addLineBreak();
		
		sc.addJavadoc(
			"A CodeCompletionHelper can be used to derive completion proposals for partial " +
			"documents. It runs the parser generated by EMFText in a special mode (i.e., the " +
			"rememberExpectedElements mode). Based on the elements that are expected by the " +
			"parser for different regions in the document, valid proposals are computed.");
	
		sc.add("public class " + getResourceClassName() + " {");
		sc.addLineBreak();
		addFields(sc);
		addMethods(sc);
		sc.add("}");
	}

	private void addFields(StringComposite sc) {
		sc.add("private " + attributeValueProviderClassName + " attributeValueProvider = new " + attributeValueProviderClassName + "();");
		sc.addLineBreak();
	}

	private void addMethods(JavaComposite sc) {
		addComputeCompletionProposalsMethod(sc);
		addParseToExpectedElementsMethod(sc);
		addRemoveDuplicateEntriesMethod(sc);
		addRemoveInvalidEntriesAtEndMethod(sc);
		addShouldRemoveMethod(sc);
		addFindPrefixMethod(sc);
		addDeriveProposalsMethod1(sc);
		addDeriveProposalsMethod2(sc);
		addHandleEnumAttributeMethod(sc);
		addHandleNCReferenceMethod(sc);
		addHandleAttributeMethod(sc);
		addDeriveProposalMethod1(sc);
		addSetPrefixesMethod(sc);
		addGetExpectedElementsAtMethod(sc);
		addGetEndMethod(sc);
		addMatchesMethod(sc);
		addGetImageMethod(sc);
	}

	private void addGetImageMethod(StringComposite sc) {
		sc.add("public " + IMAGE + " getImage(" + E_OBJECT + " element) {");
		sc.add("if (!" + PLATFORM + ".isRunning()) {");
		sc.add("return null;");
		sc.add("}");
		generatorUtil.addCreateAdapterFactoryCode(sc);
		sc.add(ADAPTER_FACTORY_LABEL_PROVIDER + " labelProvider = new " + ADAPTER_FACTORY_LABEL_PROVIDER + "(adapterFactory);");
		sc.add("return labelProvider.getImage(element);");
		sc.add("}");
	}

	private void addGetEndMethod(StringComposite sc) {
		sc.add("private int getEnd(" + expectedTerminalClassName + "[] allExpectedElements, int indexInList) {");
		sc.add(expectedTerminalClassName + " elementAtIndex = allExpectedElements[indexInList];");
		sc.add("int startIncludingHidden = elementAtIndex.getStartIncludingHiddenTokens();");
		sc.add("int startExcludingHidden = elementAtIndex.getStartExcludingHiddenTokens();");
		sc.add("for (int i = indexInList + 1; i < allExpectedElements.length; i++) {");
		sc.add(expectedTerminalClassName + " elementAtI = allExpectedElements[i];");
		sc.add("int startIncludingHiddenForI = elementAtI.getStartIncludingHiddenTokens();");
		sc.add("int startExcludingHiddenForI = elementAtI.getStartExcludingHiddenTokens();");
		sc.add("if (startIncludingHidden != startIncludingHiddenForI || startExcludingHidden != startExcludingHiddenForI) {");
		sc.add("return startIncludingHiddenForI - 1;");
		sc.add("}");
		sc.add("}");
		sc.add("return Integer.MAX_VALUE;");
		sc.add("}");
		sc.addLineBreak();
	}

	private void addSetPrefixesMethod(JavaComposite sc) {
		sc.addJavadoc(
			"Calculates the prefix for each given expected element. " +
			"The prefix depends on the current document content, the cursor position, and " +
			"the position where the element is expected."
		);
		sc.add("private void setPrefixes(" + LIST + "<" + expectedTerminalClassName + "> expectedElements, String content, int cursorOffset) {");
		sc.add("if (cursorOffset < 0) {");
		sc.add("return;");
		sc.add("}");
		sc.add("for (" + expectedTerminalClassName + " expectedElement : expectedElements) {");
		sc.add(STRING + " prefix = findPrefix(expectedElements, expectedElement, content, cursorOffset);");
		sc.add("expectedElement.setPrefix(prefix);");
		sc.add("}");
		sc.add("}");
		sc.addLineBreak();
	}

	private void addDeriveProposalMethod1(StringComposite sc) {
		sc.add("private " + COLLECTION + "<" + completionProposalClassName + "> deriveProposal(" + expectedCsStringClassName + " csString, String content, String prefix, int cursorOffset) {");
		sc.add("String proposal = csString.getValue();");
		sc.add(COLLECTION + "<" + completionProposalClassName + "> result = new " + LINKED_HASH_SET + "<" + completionProposalClassName + ">();");
		sc.add("if (matches(proposal, prefix)) {");
		sc.add("result.add(new " + completionProposalClassName + "(proposal, prefix, !\"\".equals(prefix), false));");
		sc.add("}");
		sc.add("return result;");
		sc.add("}");
		sc.addLineBreak();
	}

	private void addMatchesMethod(StringComposite sc) {
		sc.add("private boolean matches(" + STRING + " proposal, " + STRING + " prefix) {");
		sc.add("return (proposal.toLowerCase().startsWith(prefix.toLowerCase()) || " + stringUtilClassName + ".matchCamelCase(prefix, proposal) != null) && !proposal.equals(prefix);");
		sc.add("}");
		sc.addLineBreak();
	}

	private void addHandleEnumAttributeMethod(JavaComposite sc) {
		sc.add("private " + COLLECTION + "<" + completionProposalClassName + "> handleEnumAttribute(" + iMetaInformationClassName + " metaInformation, " + expectedStructuralFeatureClassName + " expectedFeature, " + E_ENUM + " enumType, String prefix, " + E_OBJECT + " container) {");
		sc.add(COLLECTION + "<" + E_ENUM_LITERAL + "> enumLiterals = enumType.getELiterals();");
		sc.add(COLLECTION + "<" + completionProposalClassName + "> result = new " + LINKED_HASH_SET + "<" + completionProposalClassName + ">();");
		sc.add("for (" + E_ENUM_LITERAL + " literal : enumLiterals) {");
		sc.add("String unResolvedLiteral = literal.getLiteral();");
		sc.addComment("use token resolver to get de-resolved value of the literal");
		sc.add(iTokenResolverFactoryClassName + " tokenResolverFactory = metaInformation.getTokenResolverFactory();");
		sc.add(iTokenResolverClassName + " tokenResolver = tokenResolverFactory.createTokenResolver(expectedFeature.getTokenName());");
		sc.add("String resolvedLiteral = tokenResolver.deResolve(unResolvedLiteral, expectedFeature.getFeature(), container);");
		sc.add("if (matches(resolvedLiteral, prefix)) {");
		sc.add("result.add(new " + completionProposalClassName + "(resolvedLiteral, prefix, !\"\".equals(prefix), true));");
		sc.add("}");
		sc.add("}");
		sc.add("return result;");
		sc.add("}");
		sc.addLineBreak();
	}

	private void addHandleAttributeMethod(StringComposite sc) {
		sc.add("private " + COLLECTION + "<" + completionProposalClassName + "> handleAttribute(" + iMetaInformationClassName + " metaInformation, " + expectedStructuralFeatureClassName + " expectedFeature, " + E_OBJECT + " container, " + E_ATTRIBUTE + " attribute, " + STRING + " prefix) {");
		sc.add(COLLECTION + "<" + completionProposalClassName + "> resultSet = new " + LINKED_HASH_SET + "<" + completionProposalClassName + ">();");
		sc.add(OBJECT + "[] defaultValues = attributeValueProvider.getDefaultValues(attribute);");
		sc.add("if (defaultValues != null) {");
		sc.add("for (Object defaultValue : defaultValues) {");
		sc.add("if (defaultValue != null) {");
		sc.add(iTokenResolverFactoryClassName + " tokenResolverFactory = metaInformation.getTokenResolverFactory();");
		sc.add("String tokenName = expectedFeature.getTokenName();");
		sc.add("if (tokenName != null) {");
		sc.add(iTokenResolverClassName + " tokenResolver = tokenResolverFactory.createTokenResolver(tokenName);");
		sc.add("if (tokenResolver != null) {");
		sc.add("String defaultValueAsString = tokenResolver.deResolve(defaultValue, attribute, container);");
		sc.add("if (matches(defaultValueAsString, prefix)) {");
		sc.add("resultSet.add(new " + completionProposalClassName + "(defaultValueAsString, prefix, !\"\".equals(prefix), true));");
		sc.add("}");
		sc.add("}");
		sc.add("}");
		sc.add("}");
		sc.add("}");
		sc.add("}");
		sc.add("return resultSet;");
		sc.add("}");
		sc.addLineBreak();
	}

	private void addHandleNCReferenceMethod(JavaComposite sc) {
		sc.add("private " + COLLECTION + "<" + completionProposalClassName + "> handleNCReference(" + iMetaInformationClassName + " metaInformation, " + E_OBJECT + " container, " + E_REFERENCE + " reference, " + STRING + " prefix, " + STRING + " tokenName) {");
		sc.addComment(
			"proposals for non-containment references are derived by calling the " + 
			"reference resolver switch in fuzzy mode."
		);
		sc.add(iReferenceResolverSwitchClassName + " resolverSwitch = metaInformation.getReferenceResolverSwitch();");
		sc.add(iTokenResolverFactoryClassName + " tokenResolverFactory = metaInformation.getTokenResolverFactory();");
		sc.add(iReferenceResolveResultClassName + "<" + E_OBJECT + "> result = new " + referenceResolveResultClassName + "<" + E_OBJECT + ">(true);");
		sc.add("resolverSwitch.resolveFuzzy(prefix, container, reference, 0, result);");
		sc.add(COLLECTION + "<" + iReferenceMappingClassName + "<" + E_OBJECT + ">> mappings = result.getMappings();");
		sc.add("if (mappings != null) {");
		sc.add(COLLECTION + "<" + completionProposalClassName + "> resultSet = new " + LINKED_HASH_SET + "<" + completionProposalClassName + ">();");
		sc.add("for (" + iReferenceMappingClassName + "<" + E_OBJECT + "> mapping : mappings) {");
		sc.add(IMAGE + " image = null;");
		sc.add("if (mapping instanceof " + elementMappingClassName + "<?>) {");
		sc.add(elementMappingClassName + "<?> elementMapping = (" + elementMappingClassName + "<?>) mapping;");
		sc.add(OBJECT + " target = elementMapping.getTargetElement();");
		sc.addComment("de-resolve reference to obtain correct identifier");
		sc.add(iTokenResolverClassName + " tokenResolver = tokenResolverFactory.createTokenResolver(tokenName);");
		sc.add("final String identifier = tokenResolver.deResolve(elementMapping.getIdentifier(), reference, container);");
		sc.add("if (target instanceof " + E_OBJECT + ") {");
		sc.add("image = getImage((" + E_OBJECT + ") target);");
		sc.add("}");
		sc.addComment("check the prefix. return only matching references");
		sc.add("if (matches(identifier, prefix)) {");
		sc.add("resultSet.add(new " + completionProposalClassName + "(identifier, prefix, true, true, image));");
		sc.add("}");
		sc.add("}");
		sc.add("}");
		sc.add("return resultSet;");
		sc.add("}");
		sc.add("return " + COLLECTIONS + ".emptyList();");
		sc.add("}");
		sc.addLineBreak();
	}

	private void addDeriveProposalsMethod2(JavaComposite sc) {
		sc.add("private " + COLLECTION + "<" + completionProposalClassName + "> deriveProposals(" + expectedTerminalClassName + " expectedTerminal, String content, " + iTextResourceClassName + " resource, int cursorOffset) {");
		sc.add(iMetaInformationClassName + " metaInformation = resource.getMetaInformation();");
		sc.add(iLocationMapClassName + " locationMap = resource.getLocationMap();");
		sc.add(iExpectedElementClassName + " expectedElement = (" + iExpectedElementClassName + ") expectedTerminal.getTerminal();");
		sc.add("if (expectedElement instanceof " + expectedCsStringClassName + ") {");
		sc.add(expectedCsStringClassName + " csString = (" + expectedCsStringClassName + ") expectedElement;");
		sc.add("return deriveProposal(csString, content, expectedTerminal.getPrefix(), cursorOffset);");
		sc.add("} else if (expectedElement instanceof " + expectedStructuralFeatureClassName + ") {");
		sc.add(expectedStructuralFeatureClassName + " expectedFeature = (" + expectedStructuralFeatureClassName + ") expectedElement;");
		sc.add(E_STRUCTURAL_FEATURE + " feature = expectedFeature.getFeature();");
		sc.add(E_CLASSIFIER + " featureType = feature.getEType();");
		sc.add(LIST + "<" + E_OBJECT + "> elementsAtCursor = locationMap.getElementsAt(cursorOffset);");
		sc.add(E_OBJECT + " container = null;");
		sc.addComment("we need to skip the proxy elements at the cursor, because they are not the container for the reference we try to complete");
		sc.add("for (int i = 0; i < elementsAtCursor.size(); i++) {");
		sc.add("container = elementsAtCursor.get(i);");
		sc.add("if (!container.eIsProxy()) {");
		sc.add("break;");
		sc.add("}");
		sc.add("}");
		
		sc.addComment(
			"if no container can be found, the cursor is probably at the " +
			"end of the document. we need to create artificial containers."
		);
		sc.add("if (container == null) {");
		sc.add("boolean attachedArtificialContainer = false;");
		sc.add(E_CLASS + " containerClass = expectedTerminal.getTerminal().getRuleMetaclass();");
		sc.add(E_STRUCTURAL_FEATURE + "[] containmentTrace = expectedTerminal.getContainmentTrace();");
		sc.add(LIST + "<" + E_OBJECT + "> contentList = null;");
		sc.add("for (" + E_STRUCTURAL_FEATURE + " eStructuralFeature : containmentTrace) {");
		sc.add("if (attachedArtificialContainer) {");
		sc.add("break;");
		sc.add("}");
		sc.add(E_CLASS + " neededClass = eStructuralFeature.getEContainingClass();");
		sc.addComment("fill the content list during the first iteration of the loop");
		sc.add("if (contentList == null) {");
		sc.add("contentList = new " + ARRAY_LIST + "<" + E_OBJECT + ">();");
		sc.add(ITERATOR + "<" + E_OBJECT + "> allContents = resource.getAllContents();");
		sc.add("while (allContents.hasNext()) {");
		sc.add(E_OBJECT + " next = allContents.next();");
		sc.add("contentList.add(next);");
		sc.add("}");
		sc.add("}");
		sc.addComment("find object to attach artificial container to");
		sc.add("for (int i = contentList.size() - 1; i >= 0; i--) {");
		sc.add(E_OBJECT + " object = contentList.get(i);");
		sc.add("if (neededClass.isInstance(object)) {");
		if (INSERT_DEBUG_OUTPUT_CODE) {
			sc.add("System.out.println(\"Found \" + object);");
		}
		sc.add(E_OBJECT + " newContainer = containerClass.getEPackage().getEFactoryInstance().create(containerClass);");
		sc.add(eObjectUtilClassName + ".setFeature(object, eStructuralFeature, newContainer, false);");
		if (INSERT_DEBUG_OUTPUT_CODE) {
			sc.add("System.out.println(\"Attached \" + newContainer);");
		}
		sc.add("container = newContainer;");
		sc.add("attachedArtificialContainer = true;");
		sc.add("}");
		sc.add("}");
		sc.add("}");
		sc.add("}");
		sc.addLineBreak();
		sc.add("if (feature instanceof " + E_REFERENCE + ") {");
		sc.add(E_REFERENCE + " reference = (" + E_REFERENCE + ") feature;");
		sc.add("if (featureType instanceof " + E_CLASS + ") {");
		sc.add("if (reference.isContainment()) {");
		sc.addComment("the FOLLOW set should contain only non-containment references");
		sc.add("assert false;");
		sc.add("} else {");
		sc.add("return handleNCReference(metaInformation, container, reference, expectedTerminal.getPrefix(), expectedFeature.getTokenName());");
		sc.add("}");
		sc.add("}");
		sc.add("} else if (feature instanceof " + E_ATTRIBUTE + ") {");
		sc.add(E_ATTRIBUTE + " attribute = (" + E_ATTRIBUTE + ") feature;");
		sc.add("if (featureType instanceof " + E_ENUM + ") {");
		sc.add(E_ENUM + " enumType = (" + E_ENUM + ") featureType;");
		sc.add("return handleEnumAttribute(metaInformation, expectedFeature, enumType, expectedTerminal.getPrefix(), container);");
		sc.add("} else {");
		sc.addComment(
			"handle EAttributes (derive default value depending on " +
			"the type of the attribute, figure out token resolver, and " + 
			"call deResolve())"
		);
		sc.add("return handleAttribute(metaInformation, expectedFeature, container, attribute, expectedTerminal.getPrefix());");
		sc.add("}");
		sc.add("} else {");
		sc.addComment("there should be no other subclass of EStructuralFeature");
		sc.add("assert false;");
		sc.add("}");
		sc.add("} else {");
		sc.addComment("there should be no other class implementing IExpectedElement");
		sc.add("assert false;");
		sc.add("}");
		sc.add("return " + COLLECTIONS + ".emptyList();");
		sc.add("}");
		sc.addLineBreak();
	}

	private void addDeriveProposalsMethod1(StringComposite sc) {
		sc.add("private " + COLLECTION + "<" + completionProposalClassName + "> deriveProposals(" + LIST + "<" + expectedTerminalClassName + "> expectedElements, String content, " + iTextResourceClassName + " resource, int cursorOffset) {");
		sc.add(COLLECTION + "<" + completionProposalClassName + "> resultSet = new " + LINKED_HASH_SET + "<" + completionProposalClassName + ">();");
		sc.add("for (" + expectedTerminalClassName + " expectedElement : expectedElements) {");
		sc.add("resultSet.addAll(deriveProposals(expectedElement, content, resource, cursorOffset));");
		sc.add("}");
		sc.add("return resultSet;");
		sc.add("}");
		sc.addLineBreak();
	}

	private void addFindPrefixMethod(StringComposite sc) {
		sc.add("private String findPrefix(" + LIST + "<" + expectedTerminalClassName + "> expectedElements, " + expectedTerminalClassName + " expectedAtCursor, String content, int cursorOffset) {");
		sc.add("if (cursorOffset < 0) {");
		sc.add("return \"\";");
		sc.add("}");
		sc.add("int end = 0;");
		sc.add("for (" + expectedTerminalClassName + " expectedElement : expectedElements) {");
		sc.add("if (expectedElement == expectedAtCursor) {");
		sc.add("final int start = expectedElement.getStartExcludingHiddenTokens();");
		sc.add("if (start >= 0  && start < Integer.MAX_VALUE) {");
		sc.add("end = start;");
		sc.add("}");
		sc.add("break;");
		sc.add("}");
		sc.add("}");
		sc.add("end = Math.min(end, cursorOffset);");
		sc.add("final String prefix = content.substring(end, Math.min(content.length(), cursorOffset));");
		if (INSERT_DEBUG_OUTPUT_CODE) {
			sc.add("System.out.println(\"Found prefix '\" + prefix + \"'\");");
		}
		sc.add("return prefix;");
		sc.add("}");
		sc.addLineBreak();
	}

	private void addRemoveInvalidEntriesAtEndMethod(StringComposite sc) {
		sc.add("private void removeInvalidEntriesAtEnd(" + LIST + "<" + expectedTerminalClassName + "> expectedElements) {");
		sc.add("for (int i = 0; i < expectedElements.size() - 1;) {");
		sc.add(expectedTerminalClassName + " elementAtIndex = expectedElements.get(i);");
		sc.add(expectedTerminalClassName + " elementAtNext = expectedElements.get(i + 1);");
		sc.add("if (elementAtIndex.getStartExcludingHiddenTokens() == elementAtNext.getStartExcludingHiddenTokens() && shouldRemove(elementAtIndex.getFollowSetID(), elementAtNext.getFollowSetID())) {");
		sc.add("expectedElements.remove(i + 1);");
		sc.add("} else {");
		sc.add("i++;");
		sc.add("}");
		sc.add("}");
		sc.add("}");
		sc.addLineBreak();
	}

	private void addRemoveDuplicateEntriesMethod(StringComposite sc) {
		sc.add("private void removeDuplicateEntries(" + LIST + "<" + expectedTerminalClassName + "> expectedElements) {");
		sc.add("for (int i = 0; i < expectedElements.size() - 1; i++) {");
		sc.add(expectedTerminalClassName + " elementAtIndex = expectedElements.get(i);");
		sc.add("for (int j = i + 1; j < expectedElements.size();) {");
		sc.add(expectedTerminalClassName + " elementAtNext = expectedElements.get(j);");
		sc.add("if (elementAtIndex.equals(elementAtNext) && elementAtIndex.getStartExcludingHiddenTokens() == elementAtNext.getStartExcludingHiddenTokens()) {");
		sc.add("expectedElements.remove(j);");
		sc.add("} else {");
		sc.add("j++;");
		sc.add("}");
		sc.add("}");
		sc.add("}");
		sc.add("}");
		sc.addLineBreak();
	}

	private void addShouldRemoveMethod(StringComposite sc) {
		sc.add("public boolean shouldRemove(int followSetID1, int followSetID2) {");
		sc.add("return followSetID1 != followSetID2;");
		sc.add("}");
		sc.addLineBreak();
	}

	private void addComputeCompletionProposalsMethod(JavaComposite sc) {
		sc.addJavadoc(
			"Computes a set of proposals for the given document assuming the cursor is " +
			"at 'cursorOffset'. The proposals are derived using the meta information, i.e., " +
			"the generated language plug-in.",
			"@param originalResource",
			"@param content the documents content",
			"@param cursorOffset",
			"@return"
		);
		
		sc.add("public " + completionProposalClassName + "[] computeCompletionProposals(" + iTextResourceClassName + " originalResource, String content, int cursorOffset) {");
		sc.add(RESOURCE_SET + " resourceSet = new " + RESOURCE_SET_IMPL + "();");
		sc.addComment("the shadow resource needs the same URI because reference resolvers may use the URI to resolve external references");
		sc.add(iTextResourceClassName + " resource = (" + iTextResourceClassName + ") resourceSet.createResource(originalResource.getURI());");
		sc.add(BYTE_ARRAY_INPUT_STREAM + " inputStream = new " + BYTE_ARRAY_INPUT_STREAM + "(content.getBytes());");
		sc.add(iMetaInformationClassName + " metaInformation = resource.getMetaInformation();");
		sc.add(iTextParserClassName + " parser = metaInformation.createParser(inputStream, null);");
		sc.add(expectedTerminalClassName + "[] expectedElements = parseToExpectedElements(parser, resource);");
		sc.add("if (expectedElements == null) {");
		sc.add("return new " + completionProposalClassName + "[0];");
		sc.add("}");
		sc.add("if (expectedElements.length == 0) {");
		sc.add("return new " + completionProposalClassName + "[0];");
		sc.add("}");

		sc.add(LIST + "<" + expectedTerminalClassName + "> expectedAfterCursor = " + ARRAYS + ".asList(getElementsExpectedAt(expectedElements, cursorOffset));");
		sc.add(LIST + "<" + expectedTerminalClassName + "> expectedBeforeCursor = " + ARRAYS + ".asList(getElementsExpectedAt(expectedElements, cursorOffset - 1));");
		if (INSERT_DEBUG_OUTPUT_CODE) {
			sc.add("System.out.println(\"parseToCursor(\" + cursorOffset + \") BEFORE CURSOR \" + expectedBeforeCursor);");
			sc.add("System.out.println(\"parseToCursor(\" + cursorOffset + \") AFTER CURSOR  \" + expectedAfterCursor);");
		}
		
		sc.add("setPrefixes(expectedAfterCursor, content, cursorOffset);");
		sc.add("setPrefixes(expectedBeforeCursor, content, cursorOffset);");

		sc.addComment("first we derive all possible proposals from the set of elements that are expected at the cursor position");
		sc.add(COLLECTION + "<" + completionProposalClassName + "> allProposals = new " + LINKED_HASH_SET + "<" + completionProposalClassName + ">();");
		sc.add(COLLECTION + "<" + completionProposalClassName + "> rightProposals = deriveProposals(expectedAfterCursor, content, resource, cursorOffset);");
		sc.add(COLLECTION + "<" + completionProposalClassName + "> leftProposals = deriveProposals(expectedBeforeCursor, content, resource, cursorOffset - 1);");
		sc.addComment(
			"second, the set of left proposals (i.e., the ones before the cursor) is " +
			"checked for emptiness. if the set is empty, the right proposals (i.e., " +
			"the ones after the cursor are removed, because it does not make sense to " +
			"propose them until the element before the cursor was completed"
		);
		sc.add("allProposals.addAll(leftProposals);");
		sc.add("if (leftProposals.isEmpty()) {");
		sc.add("allProposals.addAll(rightProposals);");
		sc.add("}");
		sc.addComment(
			"third, the proposals are sorted according to their relevance " +
			"proposals that matched the prefix are preferred over ones that did not " +
			"afterward proposals are sorted alphabetically"
		);
		sc.add("final " + LIST + "<" + completionProposalClassName + "> sortedProposals = new " + ARRAY_LIST + "<" + completionProposalClassName + ">(allProposals);");
		sc.add(COLLECTIONS + ".sort(sortedProposals);");
		sc.add("return sortedProposals.toArray(new " + completionProposalClassName + "[sortedProposals.size()]);");
		sc.add("}");
		sc.addLineBreak();
	}

	private void addParseToExpectedElementsMethod(StringComposite sc) {
		sc.add("public " + expectedTerminalClassName + "[] parseToExpectedElements(" + iTextParserClassName + " parser, " + iTextResourceClassName + " resource) {");
		sc.add("final " + LIST + "<" + expectedTerminalClassName + "> expectedElements = parser.parseToExpectedElements(null, resource);");
		sc.add("if (expectedElements == null) {");
		sc.add("return new " + expectedTerminalClassName + "[0];");
		sc.add("}");
		sc.add("removeDuplicateEntries(expectedElements);");
		sc.add("removeInvalidEntriesAtEnd(expectedElements);");
		sc.add("return expectedElements.toArray(new " + expectedTerminalClassName + "[expectedElements.size()]);");
		sc.add("}");
		sc.addLineBreak();
	}

	private void addGetExpectedElementsAtMethod(StringComposite sc) {
		sc.add("public " + expectedTerminalClassName + "[] getElementsExpectedAt(" + expectedTerminalClassName + "[] allExpectedElements, int cursorOffset) {");
		sc.add(LIST + "<" + expectedTerminalClassName + "> expectedAtCursor = new " + ARRAY_LIST + "<" + expectedTerminalClassName + ">();");
		sc.add("for (int i = 0; i < allExpectedElements.length; i++) {");
		sc.add(expectedTerminalClassName + " expectedElement = allExpectedElements[i];");
		sc.add("int startIncludingHidden = expectedElement.getStartIncludingHiddenTokens();");
		sc.add("int end = getEnd(allExpectedElements, i);");
		sc.add("if (cursorOffset >= startIncludingHidden && cursorOffset <= end) {");
		sc.add("expectedAtCursor.add(expectedElement);");
		sc.add("}");
		sc.add("}");
		sc.add("return expectedAtCursor.toArray(new " + expectedTerminalClassName + "[expectedAtCursor.size()]);");
		sc.add("}");
		sc.addLineBreak();
	}
}
