epackage concretesyntax;

import genmodel.GenClass;

import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.common.util.BasicEList;
import org.eclipse.emf.common.util.ECollections;

import java.util.Collections;
import java.util.List;
import java.util.ListIterator;

eclass ConcreteSyntax {

	/**
	 * Returns true if the given rule was defined in the given syntax.
	 * If the rule is defined in an imported syntax, this method returns
	 * false.
	 * 
	 * @param syntax the syntax that refers to the rule
	 * @param rule the rule to check
	 * @return true if the rule is contained, false if it is imported
	 */
	isImportedRule() {
		return rule.getSyntax() != this;
	}

	isAbstract() {
		if (getModifier() != null) {
			return true;
		}
		return false;
	}

	getGenClassCache() {
		if (get_genClassCache() == null) {
			set_genClassCache(#GenClassCache);
		}
		return get_genClassCache();
	}
	
	hasAnnotation() {
		for (Annotation annotation : rule.getAnnotations()) {
			if (annotation.getType() == type) {
				if (key != null) {
					for (KeyValuePair parameter : annotation.getParameters()) {
						if (key.equals(parameter.getKey())
								&& parameter.getValue().equals(value)) {
							return true;
						}
					}
				} else {
					return true;
				}
			}
		}
		return false;
	}

	getActiveStartSymbols() {
		EList<GenClass> symbols = new BasicEList<GenClass>();
		symbols.addAll(getStartSymbols());
		if (symbols.size() > 0) {
			return symbols;
		}
		
		EList<Import> imports = getImports();
		for (Import importedElement : imports) {
			final ConcreteSyntax importedSyntax = importedElement.getConcreteSyntax();
			if (importedSyntax != null) {
				symbols.addAll(importedSyntax.getActiveStartSymbols());
			}
		}
		return symbols;
	}

	getAllStartSymbols() {
		EList<GenClass> symbols = new BasicEList<GenClass>();
		symbols.addAll(getStartSymbols());
		
		EList<Import> imports = getImports();
		for (Import importedElement : imports) {
			final ConcreteSyntax importedSyntax = importedElement.getConcreteSyntax();
			if (importedSyntax != null) {
				symbols.addAll(importedSyntax.getAllStartSymbols());
			}
		}
		return symbols;
	}

	getAllRules() {
		//EStructuralFeature eFeature = ConcretesyntaxPackage.Literals.CONCRETE_SYNTAX__ALL_RULES;
		EList<Rule> l = new BasicEList<Rule>(getRules().size());
		for (Rule rule : getRules()) {
			// don't add rules that are @override rules with remove=true
			if (!isOverrideRemoveRule(rule)) {
				l.add(rule);
			}
		}
		for (Import aImport : getImports()) {
			ConcreteSyntax importedCS = aImport.getConcreteSyntax();
			if (importedCS != null) {
				outer: for (Rule importedRule : importedCS.getAllRules()) {
					for (Rule rule : getRules()) {
						// don't add rules that have @override rules for same
						// meta-class
						if (isOverrideRule(rule, importedRule.getMetaclass())) {
							continue outer;
						}
					}
					l.add(importedRule);
				}
			}
		}
		return ECollections.unmodifiableEList(l);
	}

	getOperatorRules() {
		initialiseAnnotatedOperatorRules();
		return get_operatorRules();
	}

	getOperatorRuleSubsets() {
		initialiseAnnotatedOperatorRules();
		return get_operatorRuleSubsets();
	}

	initialiseAnnotatedOperatorRules() {
		if (is_operatorRulesInitialized()) {
			return;
		}
		set_operatorRulesInitialized(true);
		List<Rule> operatorRules = getOperatorRules();
		List<String> operatorRuleSubsets = getOperatorRuleSubsets();
		for (Rule rule : getAllRules()) {
			Annotation operatorAnnotation = rule.getOperatorAnnotation();
			if (operatorAnnotation != null) {
				boolean added = false;
				for (ListIterator<Rule> it = operatorRules.listIterator(); it.hasNext();) {
					Rule expressionRule = it.next(); 
					if (expressionRule.getOperatorWeight() > rule.getOperatorWeight()) {
						operatorRules.add(it.previousIndex(), rule);
						added = true;
						break;
					}			
				}
				if (!added) {
					operatorRules.add(rule);
				}
				String identifier = operatorAnnotation.getValue(OperatorAnnotationProperty.IDENTIFIER.toString());
				operatorRuleSubsets.add(identifier);
			}
		}
	}
	
	getOperatorRuleSubset() {
		EList<Rule> subset = new BasicEList<Rule>();
		if (identifier == null) {
			return subset;
		}
		for (Rule rule : getOperatorRules()) {
			Annotation annotation = rule.getOperatorAnnotation();
			String value = annotation.getValue(OperatorAnnotationProperty.IDENTIFIER.toString());
			if (identifier.equals(value)) {
				subset.add(rule);
			}
		}
		return subset;
	}

	isOverrideRemoveRule() {
		// TODO mseifert: use constant here, move method to class 'Rule'
		return hasAnnotation(rule, AnnotationType.OVERRIDE, "remove", "true");
	}

		// TODO mseifert: move method to class 'Rule'
	isOverrideRule() {
		// TODO figure out why 'metaClass == null' is needed
		if (metaClass == null || rule.getMetaclass() == metaClass) {
			if (hasAnnotation(rule, AnnotationType.OVERRIDE, null, null)) {
				return true;
			}
		}
		return false;
	}
}