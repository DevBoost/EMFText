package org.emftext.runtime.resource.impl.code_completion;

import java.io.ByteArrayInputStream;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;

import org.eclipse.emf.ecore.EAttribute;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EClassifier;
import org.eclipse.emf.ecore.EEnum;
import org.eclipse.emf.ecore.EEnumLiteral;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.emftext.runtime.resource.IExpectedElement;
import org.emftext.runtime.resource.IReferenceMapping;
import org.emftext.runtime.resource.IReferenceResolveResult;
import org.emftext.runtime.resource.IReferenceResolverSwitch;
import org.emftext.runtime.resource.ITextParser;
import org.emftext.runtime.resource.ITextResourcePluginMetaInformation;
import org.emftext.runtime.resource.ITokenResolver;
import org.emftext.runtime.resource.ITokenResolverFactory;
import org.emftext.runtime.resource.impl.ReferenceResolveResult;
import org.emftext.runtime.util.EClassUtil;
import org.emftext.runtime.util.StringUtil;

/**
 * A CodeCompletionHelper can be used to derive completion proposals for partial 
 * documents. It run the parser generated by EMFText in a special mode (i.e., the
 * rememberExpectedElements mode). Based on the elements that are expected by the
 * parser for different regions in the document, valid proposals are computed. 
 */
public class CodeCompletionHelper {

	private final static EClassUtil eClassUtil = new EClassUtil();

	/**
	 * Computes a set of proposals for the given document assuming the cursor is 
	 * at 'offset'. The proposals are derived using the meta information, i.e.,
	 * the generated language plug-in.
	 * 
	 * @param metaInformation
	 * @param document
	 * @param offset
	 * @return
	 */
	public Collection<String> computeCompletionProposals(ITextResourcePluginMetaInformation metaInformation, String document, int offset) {
		ByteArrayInputStream inputStream = new ByteArrayInputStream(document.getBytes());
		ITextParser parser = metaInformation.createParser(inputStream, null);
		final List<IExpectedElement> expectedElements = parser.parseToExpectedElements(null);
		if (expectedElements == null) {
			return Collections.emptyList();
		}
		if (expectedElements.size() == 0) {
			return Collections.emptyList();
		}
		IExpectedElement expectedElement = getFinalExpectedElementAt(offset, expectedElements);
		System.out.println("Parser returned expectation: " + expectedElement + " for offset " + offset);
		final Collection<String> result = deriveProposals(expectedElement, document, metaInformation, offset);
		final List<String> sortedResult = new ArrayList<String>(result);
		Collections.sort(sortedResult);
		return sortedResult;
	}

	private Collection<String> deriveProposals(
			IExpectedElement expectedElement, String content, ITextResourcePluginMetaInformation metaInformation, int offset) {
		if (expectedElement instanceof ExpectedCsString) {
			ExpectedCsString csString = (ExpectedCsString) expectedElement;
			return deriveProposal(csString, content, offset);
		}
		if (expectedElement instanceof ExpectedStructuralFeature) {
			ExpectedStructuralFeature expectedFeature = (ExpectedStructuralFeature) expectedElement;
			EStructuralFeature feature = expectedFeature.getFeature();
			EClassifier featureType = feature.getEType();
			if (featureType instanceof EEnum) {
				EEnum enumType = (EEnum) featureType;
				return deriveProposals(enumType, content, offset);
			}
			EObject container = expectedFeature.getContainer();
			if (feature instanceof EReference) {
				EReference reference = (EReference) feature;
				if (featureType instanceof EClass) {
					if (reference.isContainment()) {
						EClass classType = (EClass) featureType;
						return deriveProposals(classType, metaInformation, content, offset);
					} else {
						// handle non-containment references
						IReferenceResolverSwitch resolverSwitch = metaInformation.getReferenceResolverSwitch();
						IReferenceResolveResult<EObject> result = new ReferenceResolveResult<EObject>(true);
						String prefix = findPrefix(content, offset);
						System.out.println("deriveProposals() NON-CONTAINMENT prefix = \"" + prefix + "\"");
						resolverSwitch.resolveFuzzy(prefix, container, 0, result);
						Collection<IReferenceMapping<EObject>> mappings = result.getMappings();
						if (mappings != null) {
							Collection<String> resultSet = new HashSet<String>();
							for (IReferenceMapping<EObject> mapping : mappings) {
								final String identifier = mapping.getIdentifier();
								System.out.println("deriveProposals() " + identifier);
								resultSet.add(identifier);
							}
							return resultSet;
						}
					}
				}
			}
			if (feature instanceof EAttribute) {
				EAttribute attribute = (EAttribute) feature;
				// TODO mseifert: handle EAttributes (derive default value depending on
				// the type of the attribute, figure out token resolver, and
				// call deResolve())
				Object defaultValue = getDefaultValue(attribute);
				if (defaultValue != null) {
					ITokenResolverFactory tokenResolverFactory = metaInformation.getTokenResolverFactory();
					String tokenName = expectedFeature.getTokenName();
					if (tokenName != null) {
						ITokenResolver tokenResolver = tokenResolverFactory.createTokenResolver(tokenName);
						if (tokenResolver != null) {
							// TODO mseifert: respect prefix here
							String defaultValueAsString = tokenResolver.deResolve(defaultValue, attribute, container);
							Collection<String> resultSet = new HashSet<String>();
							resultSet.add(defaultValueAsString);
							return resultSet;
						}
					}
				}
			}
			// TODO mseifert: is there another case?
		}
		return Collections.emptyList();
	}

	private Object getDefaultValue(EAttribute attribute) {
		String typeName = attribute.getEType().getName();
		if ("EString".equals(typeName)) {
			return "some" + StringUtil.capitalize(attribute.getName());
		}
		// TODO mseifert: add more default values for other types
		System.out.println("CodeCompletionHelper.getDefaultValue() unknown type " + typeName);
		return attribute.getDefaultValue();
	}

	// TODO mseifert: this is a hack. we must rather use token information from
	// the parser to figure out the prefix
	private String findPrefix(String content, int offset) {
		int lastSpace = content.substring(0, offset).lastIndexOf(" ");
		return content.substring(lastSpace + 1, offset);
	}

	private Collection<String> deriveProposals(
			EClass type,
			ITextResourcePluginMetaInformation metaInformation, 
			String content, int offset) {
		Collection<String> allProposals = new HashSet<String>();
		// find all sub classes and call parseToExpectedElements() for each
		// of them
		EClass[] availableClasses = metaInformation.getClassesWithSyntax();
		Collection<EClass> allSubClasses = eClassUtil.getSubClasses(type, availableClasses);
		for (EClass subClass : allSubClasses) {
			ITextParser parser = metaInformation.createParser(new ByteArrayInputStream(new byte[0]), null);
			final List<IExpectedElement> expectedElements = parser.parseToExpectedElements(subClass);
			if (expectedElements == null) {
				continue;
			}
			if (expectedElements.size() == 0) {
				continue;
			}
			IExpectedElement expectedElement = getFinalExpectedElementAt(0, expectedElements);
			System.out.println("computeCompletionProposals() " + expectedElement + " for offset " + offset);
			Collection<String> proposals = deriveProposals(expectedElement, content, metaInformation, offset);
			allProposals.addAll(proposals);
		}
		return allProposals;
	}

	private Collection<String> deriveProposals(EEnum enumType, String content, int offset) {
		// TODO here we must also consider the prefix and return only the
		// literals that start with the prefix
		Collection<EEnumLiteral> enumLiterals = enumType.getELiterals();
		Collection<String> result = new HashSet<String>();
		for (EEnumLiteral literal : enumLiterals) {
			String proposal = literal.getLiteral();
			result.add(proposal);
		}
		return result;
	}

	private Collection<String> deriveProposal(ExpectedCsString csString,
			String content, int offset) {
		String proposal = csString.getValue();
		
		Collection<String> result = new HashSet<String>(1);
		result.add(proposal);
		return result;
	}
	
	/**
	 * Returns the element(s) that is most suitable at the given cursor
	 * index based on the list of expected elements.
	 * 
	 * @param cursorIndex
	 * @param allExpectedElements
	 * @return
	 */
	// TODO mseifert: figure out what other combinations of elements before
	// and after the cursor position exists and which action should be taken.
	// For example, when a StructuralFeature is expected right before the
	// cursor and a CsString right after, we should return both elements.
	// TODO mseifert: this methods is only static to be accessible from the
	// JUnit tests. We should change this.
	public final static IExpectedElement getFinalExpectedElementAt(int cursorIndex,
			final List<IExpectedElement> allExpectedElements) {

		IExpectedElement expectedAtCursor = getExpectedElementAt(cursorIndex, allExpectedElements);
		IExpectedElement expectedBeforeCursor = getExpectedElementAt(cursorIndex - 1, allExpectedElements);
		System.out.println("parseToCursor() BEFORE CURSOR " + expectedBeforeCursor);
		System.out.println("parseToCursor() AT CURSOR     " + expectedAtCursor);
		IExpectedElement finalExpectedAtCursor = expectedAtCursor;
		// if the thing right before the cursor is something that could
		// be long we add it to the list of proposals
		if (expectedBeforeCursor instanceof ExpectedStructuralFeature) {
			finalExpectedAtCursor = expectedBeforeCursor;
		}
		return finalExpectedAtCursor;
	}

	private final static IExpectedElement getExpectedElementAt(int cursorIndex,
			final List<IExpectedElement> allExpectedElements) {
		
		IExpectedElement expectedAtCursor = null; 
		for (IExpectedElement expectedElement : allExpectedElements) {
			boolean isAtIndex = expectedElement.isAt(cursorIndex);
			boolean isUnknown = expectedElement.isUnknown(cursorIndex);
			if (isAtIndex) {
				//System.out.println("EXPECTED (AT CURSOR) " + expectedElement);
				expectedAtCursor = expectedElement;
			} else {
				// pick first element with unknown location
				if (isUnknown && expectedAtCursor == null) {
					expectedAtCursor = expectedElement;
					//System.out.println("EXPECTED (UNKNOWN) " + expectedElement);
				} else {
					//System.out.println("EXPECTED " + expectedElement);
				}
			}
		}
		return expectedAtCursor;
	}
}
